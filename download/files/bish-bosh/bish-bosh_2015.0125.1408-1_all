#!/usr/bin/env sh
# 
# bish-bosh (Commit 5ce8ac677234754d9e22a8020fb8a516c1d8d460 Branch master) 2015.0125.1408
# Created using shellfire (https://github.com/shellfire-dev/shellfire).
# Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
# Comment: Distribution Compilation Copyright and License
# Copyright: Copyright © 2014-2015, Raphael Cohn <raphael.cohn@stormmq.com>
# License: MIT
#  The MIT License (MIT)
#  .
#  Copyright © 2014-2015, Raphael Cohn <raphael.cohn@stormmq.com>
#  .
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#  .
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
#  .
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.
# 
# Files: *
# Copyright: Copyright © 2014-2015, Raphael Cohn <raphael.cohn@stormmq.com>
# License: MIT
#  The MIT License (MIT)
#  .
#  Copyright © 2014-2015, Raphael Cohn <raphael.cohn@stormmq.com>
#  .
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#  .
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
#  .
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.
# 
_program_name='bish-bosh'
_program_version='2015.0125.1408'
_program_package_or_build='Commit 5ce8ac677234754d9e22a8020fb8a516c1d8d460 Branch master'
_program_libPath='/usr/lib'
_program_etcPath='/etc'
_program_varPath='/var'
_program_binPath='/usr/bin'
core_libraryName="shellfire"
_core_dependency_requires="* ls
* sleep
* rm
* base64
* tr
CentOS sudo
CentOS yum
Fedora sudo
Fedora yum
RedHat sudo
RedHat yum
CentOS yum
CentOS head
Fedora yum
Fedora head
RedHat yum
RedHat head
CentOS rpm
CentOS grep
Fedora rpm
Fedora grep
RedHat rpm
RedHat grep
CentOS sudo
CentOS yum
Fedora sudo
Fedora yum
RedHat sudo
RedHat yum
CentOS sed
CentOS uname
CentOS sudo
CentOS rpm
CentOS curl
CentOS yum
Fedora sed
Fedora uname
Fedora sudo
Fedora rpm
Fedora curl
Fedora yum
RedHat sed
RedHat uname
RedHat sudo
RedHat rpm
RedHat curl
RedHat yum
Debian sudo
Debian apt-get
Homebrew brew
SuSE sudo
SuSE zypper
* awk
* kill
* grep
* head
* grep
* head
* grep
* head
* grep
* head
* grep
* head
* grep
* rm
* mv
* mv
* rm
* rm
* rm
* grep
* cat
* rm
* mv
* ln
* grep
* sleep
* kill
* kill
* rm
* mkdir
* rm
* rmdir
* mkdir
"
_core_uses_alreadySourced="shellfire/coreshellfire/core/configurationshellfire/core/pathshellfire/core/variableshellfire/core/compatibilityshellfire/core/functionsshellfire/core/variable/arrayshellfire/core/snippetshellfire/core/base64/decodeshellfire/core/temporaryFilesshellfire/core/trapshellfire/core/validateshellfire/core/commandLineshellfire/core/dependencyshellfire/core/dependency/checkshellfire/core/dependency/check/CentOSshellfire/core/dependency/check/Cygwinshellfire/core/dependency/check/Debianshellfire/core/dependency/check/Fedorashellfire/core/dependency/check/Homebrewshellfire/core/dependency/check/RedHatshellfire/core/dependency/check/SuSEshellfire/core/dependency/languagePackageManagersshellfire/core/fileshellfire/core/umaskshellfire/core/childrenshellfire/bishbosh/validateshellfire/bishbosh/filesizeshellfire/bishbosh/backendshellfire/bishbosh/backend/gnutlsshellfire/bishbosh/backend/opensslshellfire/bishbosh/backend/socatshellfire/bishbosh/backend/ncatshellfire/bishbosh/backend/nc6shellfire/bishbosh/backend/ncshellfire/bishbosh/backend/ncFreeBSDshellfire/bishbosh/backend/ncOpenBSDshellfire/bishbosh/backend/ncMacOSXshellfire/bishbosh/backend/ncMirBSDshellfire/bishbosh/backend/ncDebianOpenBSDshellfire/bishbosh/backend/ncSolarisshellfire/bishbosh/backend/ncGNUshellfire/bishbosh/backend/ncDebianTraditionalshellfire/bishbosh/backend/ncToyboxshellfire/bishbosh/backend/ncBusyBoxshellfire/bishbosh/backend/devtcpshellfire/bishbosh/backend/cryptcatshellfire/bishbosh/connectionshellfire/bishbosh/connection/readshellfire/bishbosh/connection/read/controlpacketshellfire/bishbosh/connection/read/controlpacket/CONNACKshellfire/bishbosh/connection/errorshellfire/bishbosh/connection/read/controlpacket/PINGRESPshellfire/bishbosh/connection/read/controlpacket/PUBACKshellfire/bishbosh/connection/read/controlpacket/PUBCOMPshellfire/bishbosh/connection/read/controlpacket/PUBLISHshellfire/bishbosh/connection/read/controlpacket/PUBRECshellfire/bishbosh/connection/read/controlpacket/PUBRELshellfire/bishbosh/connection/read/controlpacket/SUBACKshellfire/bishbosh/connection/read/controlpacket/UNSUBACKshellfire/bishbosh/connection/read/byteshellfire/bishbosh/connection/writeshellfire/bishbosh/connection/validateshellfire/bishbosh/connection/write/CONNECTshellfire/bishbosh/connection/write/DISCONNECTshellfire/bishbosh/connection/write/PINGREQshellfire/bishbosh/connection/write/PUBACKshellfire/bishbosh/connection/write/PUBCOMPshellfire/bishbosh/connection/write/PUBLISHshellfire/bishbosh/connection/write/PUBRECshellfire/bishbosh/connection/write/PUBRELshellfire/bishbosh/connection/write/SUBSCRIBEshellfire/bishbosh/connection/write/UNSUBSCRIBEshellfire/bishbosh/connection/handlershellfire/bishbosh/connection/backgroundshellfire/bishbosh/connection/pingshellfire/bishbosh/connection/foregroundshellfire/bishbosh/connection/clientIdshellfire/bishbosh/connection/packetIdentifier"
core_variable_array_delimiter=""
_core_compatibility_functions="core_compatibility_setSaneShellOptionscore_compability_installPushdAndPopdcore_compability_installSource"
_core_compatibility_functions_initialised="3"
_core_functions="core_trap_initialisecore_temporaryFiles_initialisecore_children_initialisecore_compatibility_executecore_configuration_loadcore_configuration_defaultscore_umask_setDefaultcore_commandLine_setLanguageDefaultscore_commandLine_parsecore_dependency_installDependencies"
_core_functions_initialised="10"
core_commandLine_exitCode_OK="0"
core_commandLine_exitCode_FAILURE="1"
core_commandLine_exitCode_MISUSEBUILTIN="2"
core_commandLine_exitCode_USAGE="64"
core_commandLine_exitCode_DATAERR="65"
core_commandLine_exitCode_NOINPUT="66"
core_commandLine_exitCode_NOUSER="67"
core_commandLine_exitCode_NOHOST="68"
core_commandLine_exitCode_UNAVAILABLE="69"
core_commandLine_exitCode_SOFTWARE="70"
core_commandLine_exitCode_OSERR="71"
core_commandLine_exitCode_OSFILE="72"
core_commandLine_exitCode_CANTCREAT="73"
core_commandLine_exitCode_IOERR="74"
core_commandLine_exitCode_TEMPFAIL="75"
core_commandLine_exitCode_PROTOCOL="76"
core_commandLine_exitCode_NOPERM="77"
core_commandLine_exitCode_CONFIG="78"
core_dependency_check_packageManagersWithPaths="CentOS Cygwin Debian Fedora Homebrew RedHat SusSE"
_core_dependency_check_functions="core_dependency_check_CentOS_checkFunctioncore_dependency_check_Cygwin_checkFunctioncore_dependency_check_Debian_checkFunctioncore_dependency_check_Fedora_checkFunctioncore_dependency_check_Homebrew_checkFunctioncore_dependency_check_RedHat_checkFunctioncore_dependency_check_SuSE_checkFunction"
_core_dependency_check_functions_initialised="7"
_core_dependency_functions="core_dependency_determinePackageManagercore_dependency_setUpPathAndInstallMissing"
_core_dependency_functions_initialised="2"
_bishbosh_backend_registration="gnutlsopensslsocatncatnc6ncncFreeBSDncOpenBSDncMacOSXncMirBSDncDebianOpenBSDncSolarisncGNUncDebianTraditionalncToyboxncBusyBoxdevtcpcryptcat"
_bishbosh_backend_registration_initialised="18"
bishbosh_connection_read_controlpacket_SUBACK_separator="	"
_program_namespace="bishbosh"
_program_ignoreDependencies="yes"
_program_copyrightAndLicenseStatement="Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
Comment: Distribution Compilation Copyright and License
Copyright: Copyright © 2014-2015, Raphael Cohn <raphael.cohn@stormmq.com>
License: MIT
 The MIT License (MIT)
 .
 Copyright © 2014-2015, Raphael Cohn <raphael.cohn@stormmq.com>
 .
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the \"Software\"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 .
 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.
 .
 THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

Files: *
Copyright: Copyright © 2014-2015, Raphael Cohn <raphael.cohn@stormmq.com>
License: MIT
 The MIT License (MIT)
 .
 Copyright © 2014-2015, Raphael Cohn <raphael.cohn@stormmq.com>
 .
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the \"Software\"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 .
 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.
 .
 THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE."
_core_dependency_internalDataSource_CentOS="ls coreutils /bin/ls
sleep coreutils /bin/sleep
rm coreutils /bin/rm
base64 coreutils /usr/bin/base64
tr coreutils /usr/bin/tr
sudo sudo /usr/bin/sudo
yum yum /usr/bin/yum
yum yum /usr/bin/yum
head coreutils /usr/bin/head
rpm rpm /bin/rpm
grep grep /bin/grep
sudo sudo /usr/bin/sudo
yum yum /usr/bin/yum
sed sed /bin/sed
uname coreutils /bin/uname
sudo sudo /usr/bin/sudo
rpm rpm /bin/rpm
curl curl /usr/bin/curl
yum yum /usr/bin/yum
awk gawk /bin/awk
kill util-linux /bin/kill
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
rm coreutils /bin/rm
mv coreutils /bin/mv
mv coreutils /bin/mv
rm coreutils /bin/rm
rm coreutils /bin/rm
rm coreutils /bin/rm
grep grep /bin/grep
cat coreutils /bin/cat
rm coreutils /bin/rm
mv coreutils /bin/mv
ln coreutils /bin/ln
grep grep /bin/grep
sleep coreutils /bin/sleep
kill util-linux /bin/kill
kill util-linux /bin/kill
rm coreutils /bin/rm
mkdir coreutils /bin/mkdir
rm coreutils /bin/rm
rmdir coreutils /bin/rmdir
mkdir coreutils /bin/mkdir
"
_core_dependency_internalDataSource_Cygwin=""
_core_dependency_internalDataSource_Debian="ls coreutils /bin/ls
sleep coreutils /bin/sleep
rm coreutils /bin/rm
base64 coreutils /usr/bin/base64
tr coreutils /usr/bin/tr
sudo sudo /usr/bin/sudo
apt-get apt /usr/bin/apt-get
awk gawk /usr/bin/gawk
kill procps /bin/kill
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
rm coreutils /bin/rm
mv coreutils /bin/mv
mv coreutils /bin/mv
rm coreutils /bin/rm
rm coreutils /bin/rm
rm coreutils /bin/rm
grep grep /bin/grep
cat coreutils /bin/cat
rm coreutils /bin/rm
mv coreutils /bin/mv
ln coreutils /bin/ln
grep grep /bin/grep
sleep coreutils /bin/sleep
kill procps /bin/kill
kill procps /bin/kill
rm coreutils /bin/rm
mkdir coreutils /bin/mkdir
rm coreutils /bin/rm
rmdir coreutils /bin/rmdir
mkdir coreutils /bin/mkdir
"
_core_dependency_internalDataSource_Fedora="ls coreutils /bin/ls
sleep coreutils /bin/sleep
rm coreutils /bin/rm
base64 coreutils /usr/bin/base64
tr coreutils /usr/bin/tr
sudo sudo /usr/bin/sudo
yum yum /usr/bin/yum
yum yum /usr/bin/yum
head coreutils /usr/bin/head
rpm rpm /bin/rpm
grep grep /bin/grep
sudo sudo /usr/bin/sudo
yum yum /usr/bin/yum
sed sed /bin/sed
uname coreutils /bin/uname
sudo sudo /usr/bin/sudo
rpm rpm /bin/rpm
curl curl /usr/bin/curl
yum yum /usr/bin/yum
awk gawk /bin/awk
kill util-linux /bin/kill
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
rm coreutils /bin/rm
mv coreutils /bin/mv
mv coreutils /bin/mv
rm coreutils /bin/rm
rm coreutils /bin/rm
rm coreutils /bin/rm
grep grep /bin/grep
cat coreutils /bin/cat
rm coreutils /bin/rm
mv coreutils /bin/mv
ln coreutils /bin/ln
grep grep /bin/grep
sleep coreutils /bin/sleep
kill util-linux /bin/kill
kill util-linux /bin/kill
rm coreutils /bin/rm
mkdir coreutils /bin/mkdir
rm coreutils /bin/rm
rmdir coreutils /bin/rmdir
mkdir coreutils /bin/mkdir
"
_core_dependency_internalDataSource_Homebrew="ls coreutils /usr/local/opt/coreutils/libexec/gnubin/ls
sleep coreutils /usr/local/opt/coreutils/libexec/gnubin/sleep
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
base64 coreutils /usr/local/opt/coreutils/libexec/gnubin/base64
tr coreutils /usr/local/opt/coreutils/libexec/gnubin/tr
brew NO_PACKAGE /usr/local/bin/brew
awk gawk /usr/local/opt/gawk/bin/awk
kill coreutils /usr/local/opt/coreutils/libexec/gnubin/kill
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
mv coreutils /usr/local/opt/coreutils/libexec/gnubin/mv
mv coreutils /usr/local/opt/coreutils/libexec/gnubin/mv
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
cat coreutils /usr/local/opt/coreutils/libexec/gnubin/cat
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
mv coreutils /usr/local/opt/coreutils/libexec/gnubin/mv
ln coreutils /usr/local/opt/coreutils/libexec/gnubin/ln
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
sleep coreutils /usr/local/opt/coreutils/libexec/gnubin/sleep
kill coreutils /usr/local/opt/coreutils/libexec/gnubin/kill
kill coreutils /usr/local/opt/coreutils/libexec/gnubin/kill
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
mkdir coreutils /usr/local/opt/coreutils/libexec/gnubin/mkdir
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
rmdir coreutils /usr/local/opt/coreutils/libexec/gnubin/rmdir
mkdir coreutils /usr/local/opt/coreutils/libexec/gnubin/mkdir
"
_core_dependency_internalDataSource_RedHat="ls coreutils /bin/ls
sleep coreutils /bin/sleep
rm coreutils /bin/rm
base64 coreutils /usr/bin/base64
tr coreutils /usr/bin/tr
sudo sudo /usr/bin/sudo
yum yum /usr/bin/yum
yum yum /usr/bin/yum
head coreutils /usr/bin/head
rpm rpm /bin/rpm
grep grep /bin/grep
sudo sudo /usr/bin/sudo
yum yum /usr/bin/yum
sed sed /bin/sed
uname coreutils /bin/uname
sudo sudo /usr/bin/sudo
rpm rpm /bin/rpm
curl curl /usr/bin/curl
yum yum /usr/bin/yum
awk gawk /bin/awk
kill util-linux /bin/kill
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
rm coreutils /bin/rm
mv coreutils /bin/mv
mv coreutils /bin/mv
rm coreutils /bin/rm
rm coreutils /bin/rm
rm coreutils /bin/rm
grep grep /bin/grep
cat coreutils /bin/cat
rm coreutils /bin/rm
mv coreutils /bin/mv
ln coreutils /bin/ln
grep grep /bin/grep
sleep coreutils /bin/sleep
kill util-linux /bin/kill
kill util-linux /bin/kill
rm coreutils /bin/rm
mkdir coreutils /bin/mkdir
rm coreutils /bin/rm
rmdir coreutils /bin/rmdir
mkdir coreutils /bin/mkdir
"
_core_dependency_internalDataSource_SusSE=""
_bishbosh_backend_ncDebianOpenBSD_start_addProxy () 
{ 
    local proxyValue="$1";
    core_variable_array_append options '-X' "$proxyValue";
    local proxyAddress="$bishbosh_proxyAddress";
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    fi;
    core_variable_array_append options '-x' "$proxyAddress";
    if core_variable_isSet bishbosh_proxyUsername; then
        if [ "$proxyValue" = 'connect' ]; then
            core_variable_array_append options -P "$bishbosh_proxyUsername";
        else
            core_message WARN "The backend ncDebianOpenBSD does not support specifing the proxy username for proxy kinds other than 'HTTP'";
        fi;
    fi;
    if core_variable_isSet bishbosh_proxyPassword; then
        core_message WARN "The backend ncDebianOpenBSD does not support specifing the proxy password";
    fi
}
_bishbosh_backend_ncFreeBSD_start_addProxy () 
{ 
    local proxyValue="$1";
    core_variable_array_append options '-X' "$proxyValue";
    local proxyAddress;
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    else
        proxyAddress="$bishbosh_proxyAddress";
    fi;
    core_variable_array_append options '-x' "$proxyAddress";
    if core_variable_isSet bishbosh_proxyUsername; then
        core_message WARN "The backend ncFreeBSD does not support specifing the proxy username";
    fi;
    if core_variable_isSet bishbosh_proxyPassword; then
        core_message WARN "The backend ncFreeBSD does not support specifing the proxy password";
    fi
}
_bishbosh_backend_ncMacOSX_start_addProxy () 
{ 
    local proxyValue="$1";
    core_variable_array_append options '-X' "$proxyValue";
    local proxyAddress;
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    else
        proxyAddress="$bishbosh_proxyAddress";
    fi;
    core_variable_array_append options '-x' "$proxyAddress";
    if core_variable_isSet bishbosh_proxyUsername; then
        core_message WARN "The backend ncMacOSX does not support specifing the proxy username";
    fi;
    if core_variable_isSet bishbosh_proxyPassword; then
        core_message WARN "The backend ncMacOSX does not support specifing the proxy password";
    fi
}
_bishbosh_backend_ncMirBSD_start_addProxy () 
{ 
    local proxyValue="$1";
    core_variable_array_append options '-X' "$proxyValue";
    local proxyAddress;
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    else
        proxyAddress="$bishbosh_proxyAddress";
    fi;
    core_variable_array_append options '-x' "$proxyAddress";
    if core_variable_isSet bishbosh_proxyUsername; then
        core_message WARN "The backend ncMirBSD does not support specifing the proxy username";
    fi;
    if core_variable_isSet bishbosh_proxyPassword; then
        core_message WARN "The backend ncMirBSD does not support specifing the proxy password";
    fi
}
_bishbosh_backend_ncOpenBSD_start_addProxy () 
{ 
    local proxyValue="$1";
    core_variable_array_append options '-X' "$proxyValue";
    local proxyAddress="$bishbosh_proxyAddress";
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    fi;
    core_variable_array_append options '-x' "$proxyAddress";
    if core_variable_isSet bishbosh_proxyUsername; then
        if [ "$proxyValue" = 'connect' ]; then
            core_variable_array_append options -P "$bishbosh_proxyUsername";
        else
            core_message WARN "The backend ncOpenBSD does not support specifing the proxy username for proxy kinds other than 'HTTP'";
        fi;
    fi;
    if core_variable_isSet bishbosh_proxyPassword; then
        core_message WARN "The backend ncOpenBSD does not support specifing the proxy password";
    fi
}
_bishbosh_backend_ncSolaris_start_addProxy () 
{ 
    local proxyValue="$1";
    core_variable_array_append options '-X' "$proxyValue";
    local proxyAddress="$bishbosh_proxyAddress";
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    fi;
    core_variable_array_append options '-x' "$proxyAddress";
    if core_variable_isSet bishbosh_proxyUsername; then
        if [ "$proxyValue" = 'connect' ]; then
            core_variable_array_append options -P "$bishbosh_proxyUsername";
        else
            core_message WARN "The backend ncSolaris does not support specifing the proxy username for proxy kinds other than 'HTTP'";
        fi;
    fi;
    if core_variable_isSet bishbosh_proxyPassword; then
        core_message WARN "The backend ncSolaris does not support specifing the proxy password";
    fi
}
_bishbosh_backend_ncat_start_addProxy () 
{ 
    local proxyValue="$1";
    local proxyAddress;
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    else
        proxyAddres="$bishbosh_proxyAddress";
    fi;
    core_variable_array_append options --proxy "$proxyAddress";
    core_variable_array_append options --proxy-type "$proxyValue";
    if core_variable_isSet bishbosh_proxyUsername; then
        local proxyAuth;
        case "$proxyValue" in 
            http)
                if core_variable_isUnset bishbosh_proxyPassword; then
                    core_exitError $core_commandLine_exitCode_CONFIG "The backend ncat requires a --proxy-password when using a HTTP proxy-kind";
                fi;
                proxyAuth="${bishbosh_proxyUsername}:${bishbosh_proxyPassword}"
            ;;
            *)
                if core_variable_isSet bishbosh_proxyPassword; then
                    core_message WARN "The backend nc does not support specifing the proxy password for SOCKS proxies";
                fi;
                proxyAuth="$bishbosh_proxyUsername"
            ;;
        esac;
        core_variable_array_append options --proxy-auth "$proxyAuth";
    fi
}
_bishbosh_connection_background_hexConversion_dd_hexdump () 
{ 
    { 
        trap '' INT HUP ABRT QUIT USR1 USR2;
        bishbosh_connection_background_hexConversion_dd_trapHandler () 
        { 
            bishbosh_connection_background_hexConversion_dd_continue=false
        };
        bishbosh_connection_background_hexConversion_dd_continue=true;
        trap bishbosh_connection_background_hexConversion_dd_trapHandler TERM;
        while $bishbosh_connection_background_hexConversion_dd_continue; do
            dd bs=1 count=1 2> /dev/null | hexdump "$@";
        done
    }
}
_bishbosh_connection_background_hexConversion_dd_od () 
{ 
    { 
        trap '' INT HUP ABRT QUIT USR1 USR2;
        bishbosh_connection_background_hexConversion_dd_trapHandler () 
        { 
            bishbosh_connection_background_hexConversion_dd_continue=false
        };
        bishbosh_connection_background_hexConversion_dd_continue=true;
        trap bishbosh_connection_background_hexConversion_dd_trapHandler TERM;
        while $bishbosh_connection_background_hexConversion_dd_continue; do
            dd bs=1 count=1 2> /dev/null | od "$@" | grep -v '^\w*$' | tr -d '\t ';
        done
    }
}
_bishbosh_connection_background_processLoop_trapHandlerPIPE () 
{ 
    core_message WARN 'Could not write DISCONNECT, probably because the network connection has already died (often due to nc handling SIGINT / Ctrl-C to a process group too quickly)';
    exit $core_commandLine_exitCode_IOERR
}
_bishbosh_connection_background_processLoop_trapHandlerTERM () 
{ 
    bishbosh_connection_continue=false;
    core_message INFO 'processLoop terminating because of signal'
}
_bishbosh_connection_defaultFolderPath () 
{ 
    local variableName="$1";
    local parentPath="$2";
    local folderName="$3";
    if core_variable_isUnset "$variableName"; then
        core_variable_setVariable "$variableName" "$(bishbosh_connection_mkdir "$parentPath" "$folderName")";
    fi
}
_bishbosh_connection_foreground_trapHandlerINT () 
{ 
    bishbosh_connection_foreground_monitorForChildExit=2;
    trap - INT HUP TERM ABRT QUIT
}
_bishbosh_connection_foreground_trapHandlerMost () 
{ 
    bishbosh_connection_foreground_monitorForChildExit=1;
    trap - INT HUP TERM ABRT QUIT
}
_bishbosh_connection_read_PUBLISH () 
{ 
    local length;
    bishbosh_connection_read_length;
    local topicLength=$length;
    local temporaryTheirPacketIdentifierFolderPath;
    temporaryTheirPacketIdentifierFolderPath="$bishbosh_connection_sessionTheirPacketIdentifiersPath"/temporary;
    rm -rf "$temporaryTheirPacketIdentifierFolderPath" 2> /dev/null || true;
    mkdir -m 0700 -p "$temporaryTheirPacketIdentifierFolderPath";
    local remainingTopicLength=$topicLength;
    local byte;
    while [ $remainingTopicLength -ne 0 ]; do
        bishbosh_connection_read_byte_blocking byte;
        bishbosh_connection_write_byte $byte >> "$temporaryTheirPacketIdentifierFolderPath"/topic-name;
        remainingTopicLength=$((remainingTopicLength-1));
    done;
    local topicName="$(<"$temporaryTheirPacketIdentifierFolderPath"/topic-name)";
    local packetIdentifier;
    local messageLength;
    local theirPacketIdentifierFolderPath;
    if [ $QoS -eq 0 ]; then
        packetIdentifier=qos0;
        messageLength=$((remainingLength-topicLength-2));
        bishbosh_connection_packetIdentifier_theirPacketIdentifierFolderPath;
        rm -rf "$theirPacketIdentifierFolderPath" 2> /dev/null || true;
    else
        bishbosh_connection_read_packetIdentifier;
        messageLength=$((remainingLength-topicLength-4));
        bishbosh_connection_packetIdentifier_theirPacketIdentifierFolderPath;
    fi;
    local readMessage;
    if [ -d "$theirPacketIdentifierFolderPath" ]; then
        if [ -f "$theirPacketIdentifierFolderPath"/transmission-counter ]; then
            readMessage=0;
        else
            readMessage=1;
        fi;
    else
        mv "$temporaryTheirPacketIdentifierFolderPath" "$theirPacketIdentifierFolderPath";
        readMessage=1;
    fi;
    local topicNameFilePath="$theirPacketIdentifierFolderPath"/topic-name;
    local remainingMessageLength=$messageLength;
    local byte;
    if [ $readMessage -eq 1 ]; then
        while [ $remainingMessageLength -ne 0 ]; do
            bishbosh_connection_read_byte_blocking byte;
            bishbosh_connection_write_byte $byte;
            remainingMessageLength=$((remainingMessageLength-1));
        done > "$theirPacketIdentifierFolderPath"/message-received;
        local messageFilePath="$theirPacketIdentifierFolderPath"/message-received;
        bishbosh_connection_handler_PUBLISH;
    else
        while [ $remainingMessageLength -ne 0 ]; do
            bishbosh_connection_read_byte_blocking byte;
            remainingMessageLength=$((remainingMessageLength-1));
        done;
        bishbosh_connection_handler_PUBLISH_again;
    fi;
    case $QoS in 
        0)
            rm -rf "$theirPacketIdentifierFolderPath" 2> /dev/null
        ;;
        1)
            bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
            bishbosh_connection_write_PUBACK;
            rm -rf "$theirPacketIdentifierFolderPath" 2> /dev/null
        ;;
        2)
            bishbosh_connection_packetIdentifier_incrementTransmissionCounter "$theirPacketIdentifierFolderPath";
            bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
            bishbosh_connection_write_PUBREC
        ;;
    esac
}
_bishbosh_connection_write_CONNECT_validateArguments () 
{ 
    if core_variable_isUnset bishbosh_connect_cleanSession; then
        bishbosh_connect_cleanSession=1;
        cleanSession=1;
    else
        core_validate_isBoolean $core_commandLine_exitCode_CONFIG 'argument' bishbosh_connect_cleanSession "$bishbosh_connect_cleanSession";
        if core_variable_isTrue "$bishbosh_connect_cleanSession"; then
            bishbosh_connect_cleanSession=1;
            cleanSession=1;
            connectFlags=$(( connectFlags + 2 ));
        else
            bishbosh_connect_cleanSession=0;
            cleanSession=0;
        fi;
    fi;
    if core_variable_isUnset bishbosh_connect_willTopic; then
        if core_variable_isSet bishbosh_connect_willMessage; then
            core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connect_willMessage' can not be set when 'bishbosh_connect_willTopic' is unset";
        fi;
        if core_variable_isSet bishbosh_connect_willMessageFilePath; then
            core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connect_willMessageFilePath' can not be set when 'bishbosh_connect_willTopic' is unset";
        fi;
        if core_variable_isSet bishbosh_connect_willQoS; then
            core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connect_willQoS' can not be set when 'bishbosh_connect_willTopic' is unset";
        fi;
        if core_variable_isSet bishbosh_connect_willRetain; then
            core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connect_willRetain' can not be set when 'bishbosh_connect_willTopic' is unset";
        fi;
        willTopic='';
        willTopicFieldLength=-1;
        willMessage='';
        willMessageFieldLength=-1;
    else
        connectFlags=$(( connectFlags + 4 ));
        willTopic="$bishbosh_connect_willTopic";
        bishbosh_connection_validate_topicName bishbosh_connect_willTopic "$willTopic";
        willTopicFieldLength=${#willTopic};
        remainingLength=$(( remainingLength + 2 + willTopicFieldLength ));
        if core_variable_isUnset bishbosh_connect_willMessage; then
            if core_variable_isUnset bishbosh_connect_willMessageFilePath; then
                willMessage='';
                willMessageFieldLength=0;
                willMessageFilePath='';
            else
                willMessage='';
                core_validate_filePathReadable $core_commandLine_exitCode_CONFIG 'argument' bishbosh_connect_willMessageFilePath "$bishbosh_connect_willMessageFilePath";
                willMessageFilePath="$bishbosh_connect_willMessageFilePath";
                willMessageFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$willMessageFilePath");
                if [ $willMessageFieldLength -gt 65535 ]; then
                    core_exitError $core_commandLine_exitCode_CONFIG "The size of the file pointed to be argument 'bishbosh_connect_willMessageFilePath' can not be longer than 65,535 bytes";
                fi;
            fi;
        else
            if core_variable_isSet bishbosh_connect_willMessageFilePath; then
                core_exitError $core_commandLine_exitCode_CONFIG "The arguments 'bishbosh_connect_willMessage' and 'bishbosh_connect_willMessageFilePath' can not both be specified";
            fi;
            willMessage="$bishbosh_connect_willMessage";
            willMessageFieldLength=${#willMessage};
            if [ $willMessageFieldLength -gt 65535 ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The size of the argument 'bishbosh_connect_willMessage' can not be longer than 65,535 bytes";
            fi;
            willMessageFilePath='';
        fi;
        bishbosh_connection_validate_fieldLength CONNECT willMessage;
        willMessageFieldLength=${#willMessage};
        remainingLength=$(( remainingLength + 2 + willMessageFieldLength ));
        if core_variable_isUnset bishbosh_connect_willQoS; then
            willQoS=0;
        else
            core_validate_isUnsignedInteger $core_commandLine_exitCode_CONFIG 'argument' bishbosh_connect_willQoS "$bishbosh_connect_willQoS";
            if [ $bishbosh_connect_willQoS -gt 2 ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connect_willQoS' must be between 0 and 2 inclusive";
            fi;
            willQoS=$bishbosh_connect_willQoS;
            connectFlags=$(( connectFlags + (willQoS << 3) ));
        fi;
        if core_variable_isSet bishbosh_connect_willRetain; then
            core_validate_isBoolean $core_commandLine_exitCode_CONFIG 'argument' bishbosh_connect_willRetain "$bishbosh_connect_willRetain";
            if core_variable_isTrue "$bishbosh_connect_willRetain"; then
                connectFlags=$(( connectFlags + 32 ));
            fi;
        fi;
    fi;
    if core_variable_isUnset bishbosh_connect_keepAlive; then
        bishbosh_connect_keepAlive=0;
        keepAlive=0;
    else
        bishbosh_validate_unsignedIntegerUpto65535Inclusive $core_commandLine_exitCode_CONFIG 'argument' bishbosh_connect_keepAlive "$bishbosh_connect_keepAlive";
        keepAlive=$bishbosh_connect_keepAlive;
    fi;
    if core_variable_isUnset bishbosh_clientId; then
        core_exitError $core_commandLine_exitCode_SOFTWARE "How is bishbosh_clientId unset?";
    else
        if [ -z "$bishbosh_clientId" ]; then
            if [ $cleanSession -eq 0 ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_clientId' can not be empty (blank) if the argument 'bishbosh_connect_cleanSession' is 0";
            fi;
        else
            clientId="$bishbosh_clientId";
        fi;
    fi;
    clientIdFieldLength=${#clientId};
    bishbosh_connection_validate_fieldLength CONNECT clientId;
    remainingLength=$(( remainingLength + 2 + clientIdFieldLength ));
    if core_variable_isUnset bishbosh_connect_username; then
        username='';
        usernameFieldLength=-1;
    else
        bishbosh_connection_validate_isUtf8 bishbosh_connect_username "$bishbosh_connect_username";
        username="$bishbosh_connect_username";
        bishbosh_connection_validate_fieldLength CONNECT username;
        usernameFieldLength=${#username};
        remainingLength=$(( remainingLength + 2 + usernameFieldLength ));
        connectFlags=$(( connectFlags + 128 ));
    fi;
    if core_variable_isUnset bishbosh_connect_password; then
        if core_variable_isUnset bishbosh_connect_passwordFilePath; then
            password='';
            passwordFieldLength=-1;
            passwordFilePath='';
        else
            password='';
            core_validate_filePathReadable $core_commandLine_exitCode_CONFIG 'argument' bishbosh_connect_passwordFilePath "$bishbosh_connect_passwordFilePath";
            passwordFilePath="$bishbosh_connect_passwordFilePath";
            passwordFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$passwordFilePath");
            if [ ${#passwordFieldLength} -gt 65535 ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The size of the file pointed to be argument 'bishbosh_connect_passwordFilePath' can not be longer than 65,535 bytes";
            fi;
        fi;
    else
        if core_variable_isSet bishbosh_connect_passwordFilePath; then
            core_exitError $core_commandLine_exitCode_CONFIG "The arguments 'bishbosh_connect_password' and 'bishbosh_connect_passwordFilePath' can not both be specified";
        fi;
        password="$bishbosh_connect_password";
        passwordFilePath='';
        bishbosh_connection_validate_fieldLength CONNECT password;
        passwordFieldLength=${#password};
        remainingLength=$(( remainingLength + 2 + passwordFieldLength ));
        connectFlags=$(( connectFlags + 64 ));
    fi
}
_bishbosh_connection_write_PUBLISH_QoS () 
{ 
    local controlPacketTypeAndFlags=48;
    local remainingLength=0;
    _bishbosh_connection_write_PUBLISH_setRetainFlag;
    local topicName;
    local topicNameFieldLength;
    _bishbosh_connection_write_PUBLISH_setTopicName;
    local message;
    local messageFieldLength;
    local messageFilePath;
    local messageUnlinkFile;
    _bishbosh_connection_write_PUBLISH_setMessage;
    _bishbosh_connection_write_PUBLISH_setQoS;
    bishbosh_connection_packetIdentifier_useOneOfOurs publish _bishbosh_connection_write_PUBLISH_storeMessage;
    _bishbosh_connection_write_PUBLISH_writeCommon;
    bishbosh_connection_packetIdentifier_write;
    _bishbosh_connection_write_PUBLISH_writeMessagePingAndUnlink
}
_bishbosh_connection_write_PUBLISH_QoS0 () 
{ 
    local controlPacketTypeAndFlags=48;
    local remainingLength=0;
    local QoS=0;
    _bishbosh_connection_write_PUBLISH_setRetainFlag;
    local topicName;
    local topicNameFieldLength;
    _bishbosh_connection_write_PUBLISH_setTopicName;
    local message;
    local messageFieldLength;
    local messageFilePath;
    local messageUnlinkFile;
    _bishbosh_connection_write_PUBLISH_setMessage;
    _bishbosh_connection_write_PUBLISH_writeCommon;
    _bishbosh_connection_write_PUBLISH_writeMessagePingAndUnlink
}
_bishbosh_connection_write_PUBLISH_setMessage () 
{ 
    if core_variable_isSet bishbosh_publish_message; then
        if core_variable_isSet bishbosh_publish_messageFilePath; then
            core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_publish_messageFilePath' can not be specified if 'bishbosh_publish_message' is";
        fi;
        if core_variable_isSet bishbosh_publish_messageUnlinkFile; then
            core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_publish_messageUnlinkFile' can not be specified if 'bishbosh_publish_message' is";
        fi;
        bishbosh_connection_validate_fieldLength PUBLISH message;
        message="$bishbosh_publish_message";
        messageFieldLength=${#message};
        messageFilePath='';
        messageUnlinkFile=0;
    else
        if core_variable_isSet bishbosh_publish_messageFilePath; then
            if core_variable_isSet bishbosh_publish_message; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_publish_message' can not be specified if 'bishbosh_publish_messageFilePath' is";
            fi;
            core_validate_filePathReadable $core_commandLine_exitCode_CONFIG 'argument' bishbosh_publish_messageFilePath "$bishbosh_publish_messageFilePath";
            message='';
            messageFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$bishbosh_publish_messageFilePath");
            messageFilePath="$bishbosh_publish_messageFilePath";
            if core_variable_isSet bishbosh_publish_messageUnlinkFile; then
                if core_variable_isTrue bishbosh_publish_messageUnlinkFile; then
                    messageUnlinkFile=0;
                else
                    messageUnlinkFile=1;
                fi;
            else
                messageUnlinkFile=0;
            fi;
        else
            if core_variable_isSet bishbosh_publish_messageUnlinkFile; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_publish_messageUnlinkFile' can not be specified if 'bishbosh_publish_messageFilePath' isn't";
            fi;
            message='';
            messageFieldLength=0;
            messageFilePath='';
            messageUnlinkFile=0;
        fi;
    fi;
    bishbosh_connection_validate_publishMessageFieldLength;
    remainingLength=$(( remainingLength + messageFieldLength ))
}
_bishbosh_connection_write_PUBLISH_setQoS () 
{ 
    controlPacketTypeAndFlags=$(( controlPacketTypeAndFlags + (QoS << 1) ));
    remainingLength=$(( remainingLength + 2 ))
}
_bishbosh_connection_write_PUBLISH_setRetainFlag () 
{ 
    if core_variable_isSet bishbosh_publish_retain; then
        if core_variable_isTrue bishbosh_publish_retain; then
            bishbosh_publish_retain=1;
            controlPacketTypeAndFlags=$(( controlPacketTypeAndFlags + 1 ));
        else
            bishbosh_publish_retain=0;
        fi;
    else
        bishbosh_publish_retain=0;
    fi
}
_bishbosh_connection_write_PUBLISH_setTopicName () 
{ 
    if core_variable_isUnset bishbosh_publish_topicName; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_publish_topicName' must be specified";
    fi;
    bishbosh_connection_validate_topicName bishbosh_publish_topicName "$bishbosh_publish_topicName";
    topicName="$bishbosh_publish_topicName";
    topicNameFieldLength=${#topicName};
    remainingLength=$(( remainingLength + 2 + topicNameFieldLength ))
}
_bishbosh_connection_write_PUBLISH_storeMessage () 
{ 
    printf '%s' $QoS > "$ourPacketIdentifierFolderPath"/qos;
    if [ $bishbosh_connect_cleanSession -eq 0 ]; then
        if [ $bishbosh_publish_retain ]; then
            printf '' > "$ourPacketIdentifierFolderPath"/retain;
        fi;
        printf '%s' "$topicName" > "$ourPacketIdentifierFolderPath"/topic-name;
        if [ $messageUnlinkFile -eq 1 ]; then
            mv "$messageFilePath" "$ourPacketIdentifierFolderPath"/message-sent;
        else
            if [ -n "$messageFilePath" ]; then
                ln "$messageFilePath" "$ourPacketIdentifierFolderPath"/message-sent 2> /dev/null || ln -s "$messageFilePath" "$ourPacketIdentifierFolderPath"/message-sent;
            else
                printf '%s' "$message" > "$ourPacketIdentifierFolderPath"/message-sent;
            fi;
        fi;
    fi
}
_bishbosh_connection_write_PUBLISH_writeCommon () 
{ 
    bishbosh_connection_write_byte "$controlPacketTypeAndFlags";
    bishbosh_connection_write_remainingLength $remainingLength;
    bishbosh_connection_write_twoByteLength $topicNameFieldLength;
    printf '%s' "$topicName"
}
_bishbosh_connection_write_PUBLISH_writeMessagePingAndUnlink () 
{ 
    if [ -z "$messageFilePath" ]; then
        printf '%s' "$message";
    else
        bishbosh_connection_write_file "$messageFilePath" $messageFieldLength;
    fi;
    bishbosh_connection_ping_recordLastSentControlPacketAt;
    if [ $messageUnlinkFile -eq 1 ]; then
        rm -f $messageUnlinkFile 2> /dev/null || true;
    fi
}
_bishbosh_connection_write_SUBSCRIBE () 
{ 
    local remainingLength=2;
    _bishbosh_connection_write_SUBSCRIBE_validateArguments "$@";
    bishbosh_connection_packetIdentifier_useOneOfOurs subscribe _bishbosh_connection_write_SUBSCRIBE_store "$@";
    printf '\202';
    bishbosh_connection_write_remainingLength $remainingLength;
    bishbosh_connection_packetIdentifier_write;
    local topicFilter;
    local topicQoS;
    while [ $# -gt 0 ]; do
        topicFilter="$1";
        topicQoS=$2;
        shift 2;
        bishbosh_connection_write_twoByteLength ${#topicFilter};
        printf '%s' "$topicFilter";
        bishbosh_connection_write_byte $topicQoS;
    done;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
_bishbosh_connection_write_SUBSCRIBE_store () 
{ 
    local topicFiltersPath="$ourPacketIdentifierFolderPath"/topic-filters;
    local topicFilter;
    local topicQoS;
    local index=0;
    local indexPath;
    while [ $# -gt 0 ]; do
        topicFilter="$1";
        topicQoS=$2;
        indexPath="$topicFiltersPath"/"$(printf '%09s' $index)";
        mkdir -m 0700 -p "$indexPath";
        printf '%s' $topicQoS > "$indexPath"/topic-qos;
        printf '%s' "$topicFilter" > "$indexPath"/topic-filter;
        shift 2;
        index=$((index+1));
    done
}
_bishbosh_connection_write_SUBSCRIBE_validateArguments () 
{ 
    if [ $# -lt 2 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_subscribe_topicQoSPairs' must contain at least one pair";
    fi;
    if [ $(($#%2)) -ne 0 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_subscribe_topicQoSPairs' must contain pairs";
    fi;
    local topicFilter;
    local topicQoS;
    local index=0;
    local topicFilterFieldLength;
    while [ $# -gt 0 ]; do
        topicFilter="$1";
        bishbosh_connection_validate_topicFilter 'bishbosh_subscribe_topicQoSPairs' $index "$topicFilter";
        topicQoS=$2;
        case "$topicQoS" in 
            0 | 1 | 2)
                :
            ;;
            *)
                core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_subscribe_topicQoSPairs' at pair index '$index' must contain QoS values between 0 to 2 (inclusive), not '$topicQoS'"
            ;;
        esac;
        topicFilterFieldLength=${#topicFilter};
        remainingLength=$(( remainingLength + 3 + topicFilterFieldLength ));
        shift 2;
        index=$((index+1));
    done
}
_bishbosh_connection_write_UNSUBSCRIBE () 
{ 
    local remainingLength=2;
    _bishbosh_connection_write_UNSUBSCRIBE_validateArguments "$@";
    bishbosh_connection_packetIdentifier_useOneOfOurs unsubscribe _bishbosh_connection_write_UNSUBSCRIBE_store "$@";
    printf '\242';
    bishbosh_connection_write_remainingLength $remainingLength;
    bishbosh_connection_packetIdentifier_write;
    local topicFilter;
    while [ $# -gt 0 ]; do
        topicFilter="$1";
        bishbosh_connection_write_twoByteLength ${#topicFilter};
        printf '%s' "$topicFilter";
        shift 1;
    done;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
_bishbosh_connection_write_UNSUBSCRIBE_store () 
{ 
    local topicFiltersPath="$ourPacketIdentifierFolderPath"/topic-filters;
    local topicFilter;
    local index=0;
    local indexPath;
    while [ $# -gt 0 ]; do
        topicFilter="$1";
        indexPath="$topicFiltersPath"/"$(printf '%09s' $index)";
        mkdir -m 0700 -p "$indexPath";
        printf '%s' "$topicFilter" > "$indexPath"/topic-filter;
        shift 1;
        index=$((index+1));
    done
}
_bishbosh_connection_write_UNSUBSCRIBE_validateArguments () 
{ 
    if [ $# -eq 0 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_unsubscribe_topics' must contain at least one topic";
    fi;
    local topicFilter;
    local topicFilterFieldLength;
    local index=0;
    while [ $# -gt 0 ]; do
        topicFilter="$1";
        bishbosh_connection_validate_topicFilter 'bishbosh_unsubscribe_topics' $index "$topicFilter";
        shift 1;
        topicFilterFieldLength=${#topicFilter};
        remainingLength=$(( remainingLength + 2 + topicFilterFieldLength ));
        index=$((index+1));
    done
}
_bishbosh_connection_write_rePUBLISH_setMessage () 
{ 
    message='';
    messageFilePath="$ourPacketIdentifierFolderPath"/message-sent;
    messageFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$messageFilePath");
    messageUnlinkFile=0
}
_bishbosh_connection_write_rePUBLISH_setQoS () 
{ 
    if [ -f "$ourPacketIdentifierFolderPath"/1 ]; then
        QoS=1;
    else
        if [ -f "$ourPacketIdentifierFolderPath"/2 ]; then
            QoS=2;
        else
            core_exitError $core_commandLine_exitCode_DATAERR "There is not QoS 1 or 2 file for packet identifier '$packetIdentifier' in stored session state at '$bishbosh_connection_sessionOurPacketIdentifiersPath'.";
        fi;
    fi;
    QoS=$(<"$ourPacketIdentifierFolderPath"/qos)
}
_bishbosh_connection_write_rePUBLISH_setRetainFlag () 
{ 
    if [ -f "$ourPacketIdentifierFolderPath"/retain ]; then
        controlPacketTypeAndFlags=$(( controlPacketTypeAndFlags + 1 ));
    fi
}
_bishbosh_connection_write_rePUBLISH_setTopicName () 
{ 
    topicName="$(<"$ourPacketIdentifierFolderPath"/topic-name)";
    topicNameFieldLength=${#topicName};
    remainingLength=$(( remainingLength + 2 + topicNameFieldLength ))
}
_bishbosh_publish () 
{ 
    local QoS=$1;
    local bishbosh_publish_topicName="$2";
    local bishbosh_publish_retain="$3";
    if [ $QoS -eq 0 ]; then
        _bishbosh_connection_write_PUBLISH_QoS0;
    else
        _bishbosh_connection_write_PUBLISH_QoS;
    fi
}
_core_base64_decode_file () 
{ 
    local index62Character="$1";
    local index63Character="$2";
    local singleByteLineMethod="$3";
    local carriageReturn="$(printf '\r')";
    local accumulatedValue;
    local value;
    local valueShift;
    local character;
    accumulatedValue=0;
    valueShift=18;
    local equalsCount=0;
    $singleByteLineMethod | while IFS='' read -r character || [ -n "$character" ]; do
        if [ -z "$character" ]; then
            continue;
        fi;
        if [ $equalsCount -eq 2 ]; then
            core_exitError $core_commandLine_exitCode_DATAERR "'=' embedded in base64-encoded data, not at end";
        fi;
        case "$character" in 
            "$carriageReturn")
                continue
            ;;
            A)
                value=0
            ;;
            B)
                value=1
            ;;
            C)
                value=2
            ;;
            D)
                value=3
            ;;
            E)
                value=4
            ;;
            F)
                value=5
            ;;
            G)
                value=6
            ;;
            H)
                value=7
            ;;
            I)
                value=8
            ;;
            J)
                value=9
            ;;
            K)
                value=10
            ;;
            L)
                value=11
            ;;
            M)
                value=12
            ;;
            N)
                value=13
            ;;
            O)
                value=14
            ;;
            P)
                value=15
            ;;
            Q)
                value=16
            ;;
            R)
                value=17
            ;;
            S)
                value=18
            ;;
            T)
                value=19
            ;;
            U)
                value=20
            ;;
            V)
                value=21
            ;;
            W)
                value=22
            ;;
            X)
                value=23
            ;;
            Y)
                value=24
            ;;
            Z)
                value=25
            ;;
            a)
                value=26
            ;;
            b)
                value=27
            ;;
            c)
                value=28
            ;;
            d)
                value=29
            ;;
            e)
                value=30
            ;;
            f)
                value=31
            ;;
            g)
                value=32
            ;;
            h)
                value=33
            ;;
            i)
                value=34
            ;;
            j)
                value=35
            ;;
            k)
                value=36
            ;;
            l)
                value=37
            ;;
            m)
                value=38
            ;;
            n)
                value=39
            ;;
            o)
                value=40
            ;;
            p)
                value=41
            ;;
            q)
                value=42
            ;;
            r)
                value=43
            ;;
            s)
                value=44
            ;;
            t)
                value=45
            ;;
            u)
                value=46
            ;;
            v)
                value=47
            ;;
            w)
                value=48
            ;;
            x)
                value=49
            ;;
            y)
                value=50
            ;;
            z)
                value=51
            ;;
            0)
                value=52
            ;;
            1)
                value=53
            ;;
            2)
                value=54
            ;;
            3)
                value=55
            ;;
            4)
                value=56
            ;;
            5)
                value=57
            ;;
            6)
                value=58
            ;;
            7)
                value=59
            ;;
            8)
                value=60
            ;;
            9)
                value=61
            ;;
            "$index62Character")
                value=62
            ;;
            "$index63Character")
                value=63
            ;;
            '=')
                if [ $valueSift -eq 18 ]; then
                    core_exitError $core_commandLine_exitCode_DATAERR "'=' can start a triple in base64-encoded data";
                fi;
                equalsCount=$((equalsCount+1));
                value=0
            ;;
            *)
                core_exitError $core_commandLine_exitCode_DATAERR "Unexpected character '$character' in base64-encoded data"
            ;;
        esac;
        accumulatedValue=$(( (value << valueShift) + accumulatedValue));
        if [ $valueShift -ne 0 ]; then
            valueShift=$((valueShift-6));
            continue;
        fi;
        valueShift=18;
        printf "\\$(printf '%o' $((accumulatedValue >> 16)))";
        printf "\\$(printf '%o' $(((accumulatedValue >> 8) & 255)))";
        printf "\\$(printf '%o' $((accumulatedValue & 255)))";
    done;
    case $valueShift in 
        18)
            :
        ;;
        12)
            core_exitError $core_commandLine_exitCode_DATAERR "Missing final character in base64-encoded data"
        ;;
        8)
            printf "\\$(printf '%o' $((accumulatedValue >> 16)))"
        ;;
        0)
            printf "\\$(printf '%o' $((accumulatedValue >> 16)))";
            printf "\\$(printf '%o' $(((accumulatedValue >> 8) & 255)))"
        ;;
    esac
}
_core_base64_decode_file_awk () 
{ 
    awk '{for(i=1;i<=length;i++) print substr($0, i, 1)}' "$encodedFilePath"
}
_core_base64_decode_file_fold () 
{ 
    fold -b -w 1 "$encodedFilePath"
}
_core_children_killAll_callback () 
{ 
    local pid;
    for pid in "$@";
    do
        kill -TERM "$pid" 2> /dev/null || true;
    done
}
_core_compatibility_builtInDoesNotExist () 
{ 
    local builtInName="$1";
    local value="$(PATH='' core_compatibility_which "$builtInName")";
    if [ "$builtInName" = "$value" ]; then
        return 1;
    fi;
    return 0
}
_core_configuration_load () 
{ 
    local actualPath="$1";
    if [ ! -e "$actualPath" ]; then
        core_message INFO "Configuration file '$actualPath' does not exist; ignoring";
        return 0;
    else
        if [ -f "$actualPath" ]; then
            if [ ! -r "$actualPath" ]; then
                core_message WARN "Configuration file '$actualPath' is not readable; ignoring";
                return 0;
            fi;
            if [ ! -s "$actualPath" ]; then
                core_message WARN "Configuration file '$actualPath' is empty; ignoring";
                return 0;
            fi;
            if [ -x "$actualPath" ]; then
                core_message WARN "Configuration file '$actualPath' is executable and should not be; ignoring";
                return 0;
            fi;
            if _core_configuration_validateConfigurationFileIsInsecurelyOwned; then
                return 0;
            fi;
            . "$actualPath" || core_exitError $core_commandLine_exitCode_OSFILE "Could not load '$actualPath'";
        else
            if [ -d "$actualPath" ]; then
                if [ ! -r "$actualPath" ]; then
                    core_message WARN "Configuration folder '$actualPath' is not readable; ignoring";
                    return 0;
                fi;
                if [ ! -x "$actualPath" ]; then
                    core_message WARN "Configuration folder '$actualPath' is not searchable; ignoring";
                    return 0;
                fi;
                local filePath;
                pushd "$actualPath";
                set +f;
                for filePath in *;
                do
                    set -f;
                    if [ ! -e "$filePath" ]; then
                        continue;
                    fi;
                    _core_configuration_load "$filePath";
                done;
                set -f;
                popd;
            else
                core_message WARN "Configuration path '$actualPath' resolves to neither a file or folder; ignoring";
                return 0;
            fi;
        fi;
    fi
}
_core_configuration_validateConfigurationFileIsInsecurelyOwned () 
{ 
    if core_variable_doesNotStartWith "$actualPath" '/etc'; then
        return 1;
    fi;
    local permissions;
    local links;
    local uid;
    local gid;
    local size;
    local garbageDateAndName;
    IFS=' ' read -r permissions links uid gid size garbageDateAndName  <<-EOF
$(ls -a -l -L -n "$actualPath")
EOF

    if [ $uid -ne 0 ]; then
        core_message WARN "Configuration file '$actualPath' is not owned by root; ignoring";
        return 0;
    fi;
    if [ $gid -ne 0 ]; then
        core_message WARN "Configuration file '$actualPath' is not in root's group; ignoring";
        return 0;
    fi;
    if core_variable_doesNotStartWith "$permissions" '-rw-r--r--'; then
        core_message WARN "Configuration file '$actualPath' has permissions that are not -rw-r--r--; ignoring";
        return 0;
    fi;
    local parentPath="$(core_compatibility_basename "$actualPath")";
    ls -a -l -L -n "$actualPath" | while IFS=' ' read -r permissions links uid gid size garbageDateAndName; do
        if [ "$permissions" = 'total' ]; then
            continue;
        fi;
        if [ $uid -ne 0 ]; then
            core_message WARN "Configuration file '$actualPath' lives in a folder not owned by root; ignoring";
            return 0;
        fi;
        if [ $gid -ne 0 ]; then
            core_message WARN "Configuration file '$actualPath' lives in a folder not owned by root's group; ignoring";
            return 0;
        fi;
        if core_variable_doesNotStartWith "$permissions" '-rwxr-xr-x'; then
            core_message WARN "Configuration file '$actualPath' lives in a folder with permissions not set to '-rwxr-xr-x'; ignoring";
            return 0;
        fi;
        break;
    done;
    return 1
}
_core_dependency_addFromExternalDataSources () 
{ 
    local externalDataSourceFolderPath;
    local externalDataSourceFilePath;
    if core_variable_isSet HOME; then
        set -- "$HOME"/."$_program_name" "$HOME"/."$core_libraryName" "$_program_etcPath"/"$_program_name" "$_program_etcPath"/"$core_libraryName";
    else
        set -- "$_program_etcPath"/"$_program_name" "$_program_etcPath"/"$core_libraryName";
    fi;
    for externalDataSourceFolderPath in "$@";
    do
        externalDataSourceFilePath="$externalDataSourceFolderPath"/paths.d/"$packageManager"/"$programName".path;
        if ! core_path_isReadableNonEmptyFilePath "$externalDataSourceFilePath"; then
            continue;
        fi;
        IFS=' ' read -r pathProgramName pathPackage pathAbsoluteFilePath < "$externalDataSourceFilePath";
        if [ ! -e "$pathAbsoluteFilePath" ]; then
            _core_dependency_addToPackagesToInstallIfRequired;
        fi;
        _core_dependency_addToReplacementPathIfRequired "$pathAbsoluteFilePath";
        foundInternally=1;
        return;
    done
}
_core_dependency_addFromInternalDataSource () 
{ 
    local internalDataSourceName="_core_dependency_internalDataSource_${packageManager}";
    if core_variable_isUnset "$internalDataSourceName"; then
        foundInternally=0;
        return 0;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$internalDataSourceName";
    while IFS=' ' read -r pathProgramName pathPackage pathAbsoluteFilePath; do
        if [ "$programName" = "$pathProgramName" ]; then
            foundInternally=1;
            if [ ! -e "$pathAbsoluteFilePath" ]; then
                _core_dependency_addToPackagesToInstallIfRequired;
            fi;
            _core_dependency_addToReplacementPathIfRequired "$pathAbsoluteFilePath";
            return 0;
        fi;
        :;
    done  <<-EOF
$core_variable_indirectValue_result
EOF

    foundInternally=0;
    return 0
}
_core_dependency_addToPackagesToInstallIfRequired () 
{ 
    if core_variable_array_contains packagesToInstall "$pathPackage"; then
        return 0;
    fi;
    core_variable_array_append packagesToInstall "$pathPackage"
}
_core_dependency_addToReplacementPathIfRequired () 
{ 
    local filePath="$1";
    local folderPath="$(core_compatibility_dirname "$filePath")";
    local replacementPathFragment;
    local IFS=':';
    for replacementPathFragment in $replacementPath;
    do
        if [ "$replacementPathFragment" = "$folderPath" ]; then
            return 0;
        fi;
    done;
    replacementPath="$folderPath:$replacementPath"
}
_core_dependency_check_CentOS_checkPackageInstalled () 
{ 
    local packageName="$1";
    rpm -qa | grep -q "^${packageName}-"
}
_core_dependency_check_CentOS_detectIfYumSupportsAssumeYes () 
{ 
    yum --version | head -n 1
}
_core_dependency_check_CentOS_installRepository_epel () 
{ 
    if _core_dependency_check_CentOS_checkPackageInstalled 'epel-release'; then
        return 0;
    fi;
    sudo -p "Please enter the password for %p for sudo to run yum install epel-release: " yum ${yumVerbosity} -y install epel-release
}
_core_dependency_check_CentOS_installRepository_repoforge () 
{ 
    if _core_dependency_check_CentOS_checkPackageInstalled 'rpmforge-release'; then
        return 0;
    fi;
    local TMP_FILE;
    core_temporaryFiles_newFileToRemoveOnExit;
    local temporaryFile="$TMP_FILE";
    sed -e 's/release /release./g' -e 's/.* release\.//g' -e 's/ .*$//g' /etc/redhat-release > "$temporaryFile";
    local release;
    local garbage;
    IFS='.' read -r release garbage < "$temporaryFile";
    local downloadUrl="http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el${release}.rf.$(uname -m).rpm";
    local repoForgeReleaseRpmFilePath="$temporaryFile";
    sudo -p "Please enter the password for %p for sudo to import repoforge repository's key (please note this is only available over _HTTP_): " rpm --import http://apt.sw.be/RPM-GPG-KEY.dag.txt 2> /dev/null || true;
    curl --silent --location --url "$downloadUrl" > "$repoForgeReleaseRpmFilePath";
    rpm -K "$repoForgeReleaseRpmFilePath" > /dev/null 2> /dev/null || core_exitError $core_commandLine_exitCode_IOERR "Downloaded repoforge package corrupt or tampered with";
    sudo -p "Please enter the password for %p for sudo to add the repoforge repository" rpm --quiet -ivh "$repoForgeReleaseRpmFilePath";
    sudo -p "Please enter the password for %p for sudo to update yum: " yum --quiet makecache
}
_core_dependency_check_CentOS_parsePackageName () 
{ 
    repositoryName='';
    packageName='';
    IFS='/' read -r repositoryName packageName  <<-EOF
${fullyQualifiedPackageName}
EOF

    if [ -z "$packageName" ]; then
        packageName="$repositoryName";
        repositoryName='';
    fi
}
_core_temporaryFiles_removeAll_callback () 
{ 
    local pathToDelete;
    for pathToDelete in "$@";
    do
        if [ ! -e "$pathToDelete" ]; then
            continue;
        fi;
        if rm -r -f "$pathToDelete" > /dev/null 2> /dev/null; then
            continue;
        fi;
        if core_compatibility_whichNoOutput sudo; then
            sudo -p "Please enter the password for %p to forcibly rm the temporary path '$pathToDelete': " rm -r -f "$pathToDelete" || core_message WARN "Could not forcibly delete temporary path '$pathToDelete'";
        fi;
    done
}
_core_trap_executeOnTrap () 
{ 
    local trapName="$1";
    local arrayName="core_trap_handlers_${trapName}";
    if core_variable_array_isUnset "$arrayName"; then
        return 0;
    fi;
    core_variable_array_iterateAsCallbacks "$arrayName"
}
_core_variable_array_contains_check () 
{ 
    if [ "$core_variable_array_element" = "$containsValue" ]; then
        return 0;
    fi;
    return 1
}
_core_variable_array_isEmpty () 
{ 
    local core_variable_indirectValue_result;
    core_variable_indirectValue "${variableName}_initialised";
    [ $core_variable_indirectValue_result -eq 0 ]
}
_core_variable_characterByCharacter () 
{ 
    local index=0;
    local core_variable_character;
    while IFS='' read -r core_variable_character; do
        if [ -z "$character" ]; then
            character="
";
        fi;
        $callback;
        index=$((index+1));
    done
}
_core_variable_copy () 
{ 
    local valueToCopy="$1";
    local copies=$2;
    local count=0;
    while [ $count -lt $copies ]; do
        copy="${copy}${valueToCopy}";
        count=$((count + 1));
    done
}
_core_variable_parseBoolean () 
{ 
    case "$1" in 
        true | True | TRUE | T | yes | Yes | YES | Y | on | On | ON | 1)
            return $2
        ;;
        false | False | FALSE | F | no | No | NO | N | off | Off | OFF | 0)
            return $3
        ;;
        *)
            return $4
        ;;
    esac
}
_program_commandLine_handleNonOptions () 
{ 
    local scriptletFilePath;
    local suitableForSourceBuiltInFilePath;
    for scriptletFilePath in "$@";
    do
        suitableForSourceBuiltInFilePath=$(core_compatibility_dirname "$scriptletFilePath")/"$(core_compatibility_basename "$scriptletFilePath")";
        . "$suitableForSourceBuiltInFilePath" || core_exitError "Could not source SCRIPTLET '$scriptletFilePath'";
    done
}
_program_commandLine_helpMessage () 
{ 
    _program_commandLine_helpMessage_usage="[OPTION]... -- [SCRIPTLETS]...";
    _program_commandLine_helpMessage_description="Connects to a MQTT server and runs SCRIPTLETS.
May be used as a command interpreter in scripts starting #!/usr/bin/env ${_program_name}
if on the PATH.";
    _program_commandLine_helpMessage_options="
  -t, --tunnel TUNNEL       Network tunnel TUNNEL to use. One of 'none', 'tls',
                            'cryptcat'. Defaults to '${_program_default_tunnel}'.
                            'WebSockets', 'WebSocketsSecure', 'SSH' and 'telnet'
                            are unimplemented but possible if there's demand.
  -s, --server HOST         Server hostname, HOST, is a hostname,
                            IPv4 address, IPv6 address, unix domain socket
                            path or serial character device path.
  -p, --port PORT           Server PORT. Ignored for Unix domain sockets and
                            serial devices.
                            Defaults to 1883 or 8883 depending on --tunnel.
  -i, --client-id ID        Specifies the client id ID to use. Any SCRITPLETS
                            found at --clients-path PATH/ID will then be
                            sourced. SCRIPTLETS control how a connection is
                            managed. If this option is not used, then an
                            empty ID is used if Clean Session is 1 (unless
                            the switch --random-client-id is used, below).
  -r, --random-client-id    Specify this to force a random client-id instead
                            of an empty one if Clean Session is 1 and
                            --client-id isn't specified. Invalid if
                            Clean Session is 0.
  -x, --ping-timeout SECS   Maximum time to wait in SECS seconds for a
                            PINGRESP packet if keep-alive is non-zero.
                            Defaults to '${_program_default_pingTimeout}'
  -w, --connect-timeout SECS  Maximum time in 'SECS' seconds to wait to try
                            to connect. Not all backends support this.
                            Some older netcats interpret this as also
                            being an idle timeout. 0 is infinity.
                            Defaults to '${_program_default_connectTimeout}'
  -b, --backends A,B,...    Backend types A,B,... to talk to MQTT server.
                            Ordered in preference order. First found used.
                            Comma separated. Most backends do not support
                            tunnels TUNNEL other than 'MQTT'.
                            Defaults to '${_program_default_backends}'.
  -c, --client-path PATH    PATH to folder containing client scriptlets.
                            Defaults to '${_program_default_clientPath}'.
  -d, --session-path PATH   PATH to folder containing session data for
                            Clean Session = 0 clients.
                            Defaults to '${_program_default_sessionPath}'.
  -l, --lock-path PATH      PATH to a parent folder for locking with a
                            Mutex; ensures only one copy runs at a time.
                            Defaults to '${_program_default_lockPath}'.
      --filesize-algorithm  ALGO  Choose a different binary dependency to
                            calculate file sizes. ALGO may be one of 'ls',
                            'GNUAndBusyBoxStat', 'BSDStat', and 'ToyboxStat'
                            Defaults to '${_program_default_filesizeAlgorithm}'.
      --read-latency MSECS  Maximum time to block for when reading in
                            MSECS milliseconds between 0 and 1000
                            inclusive. 0 has different meaning in
                            'zsh' as opposed to 'bash'.
                            Defaults to '${_program_default_readLatency}'.
                            Default varies by detected shell and OS.
      --transport TRANSPT   TRANSPT of inet, inet4, inet6, unix or serial.
                            Defaults to 'inet'
      --source-address S    Bind to network interface with address S.
                            Should not normally be needed.
                            Turn off with ''.
                            Off by default.
                            Does not work with transports 'unix' or
                            'serial'.
      --source-port PORT    Send packets from port PORT.
                            Should not normally be needed.
                            Turn off with ''.
                            Off by default.
                            Does not work with transport 'unix'.
      --proxy-kind KIND     Use a particular KIND of proxy.
                            KIND is 'SOCKS4','SOCKS4a', 'SOCKS5',
                            'HTTP' or 'none'.
                            Turn off with 'none'.
                            Off by default.
                            Does not work with transports 'unix' or
                            'serial'.
                            Not all backends support this option.
      --proxy-server HOST   Connect to a proxy on a given HOST.
                            Turn off with ''.
                            Off by default.
                            Does not work with transports 'unix' or
                            'serial'.
      --proxy-port PORT     Connect to a proxy on a given PORT.
                            Turn off with ''.
                            Off by default, but defaults to 1080
                            for SOCKS4 / SOCKS4a / SOCKS5 and 3128 for HTTP.
                            Does not work with transports 'unix' or
                            'serial'.
      --proxy-username UN   Connect to a proxy using username UN.
                            Turn off with ''.
                            Off by default.
                            Does not work with transports 'unix' or
                            'serial'.
                            Insecure - use configuration instead.
                            Not all proxies support this option.
      --proxy-password PWD  Connect to a proxy using password PWD.
                            Turn off with ''.
                            Off by default.
                            Does not work with transports 'unix' or
                            'serial'.
                            Insecure - use configuration instead.
                            Not all proxies support this option.
      --tunnel-tls-ca-path PATH  Folder PATH containing certificate
                            authorities in PEM format with OpenSSL
                            hashes. Must not be specified if 
                            --tunnel-tls-ca-bundle is.
      --tunnel-tls-ca-bundle FILE  PEM-encoded FILE file containing
                            all trusted certificate authorities.
                            Must not be specified if 
                            --tunnel-tls-ca-path is.
      --tunnel-tls-certificate FILE  TLS certificate FILE for client
                            authentication. Must be PEM-encoded.
                            Required if --tunnel-tls-key
                            is specified.
      --tunnel-tls-key FILE  TLS key FILE for client
                            authentication. Must be PEM-encoded.
                            Required if --tunnel-tls-certificate
                            is specified.
      --tunnel-tls-use-der [BOOL]  Boolean BOOL (0/1,on/off) to enable
                            interpretation of certificate and key as
                            DER encoded.
                            Defaults to ${_program_default_bishbosh_tunnelTlsUseDer}.
      --tunnel-tls-verify [BOOL]  Boolean BOOL (0/1,on/off) to enable
                            verification of server certificates.
                            Defaults to ${_program_default_bishbosh_tunnelTlsVerify} (verification).
      --tunnel-tls-ciphers STR  Cipher string. Format is specific to
                            backend. For openssl-based backends
                            (most) see man 5 ciphers. For GnuTLS
                            see man gnutls. 
      --tunnel-cryptcat-password PWD  Password for cryptcat.";
    _program_commandLine_helpMessage_optionsSpacing='   ';
    _program_commandLine_helpMessage_configurationKeys="
  bishbosh_tunnel         Equivalent to --tunnel
  bishbosh_server         Equivalent to --server
  bishbosh_port           Equivalent to --port
  bishbosh_clientId       Equivalent to --client-id
  bishbosh_randomClientId Equivalent to --random-client-id
  bishbosh_pingTimeout    Equivalent to --ping-timeout
  bishbosh_connectTimeout  Equalivant to --connect-timeout
  bishbosh_backends       Equivalent to --backends
  bishbosh_clientPath     Equivalent to --clients-path
  bishbosh_sessionPath    Equivalent to --session-path
  bishbosh_lockPath       Equivalent to --lock-path
  bishbosh_filesizeAlgorithm  Equivalent to --filesize-algorithm
  bishbosh_readLatency    Equivalent to --read-latency
  bishbosh_transport      Equivalent to --transport
  bishbosh_sourceAddress  Equivalent to --source-address
  bishbosh_sourcePort     Equivalent to --source-port
  bishbosh_proxyKind      Equivalent to --proxy-kind
  bishbosh_proxyServer    Equivalent to --proxy-server
  bishbosh_proxyPort      Equivalent to --proxy-port
  bishbosh_proxyUsername  Equivalent to --proxy-username
  bishbosh_proxyPassword  Equivalent to --proxy-password
  
The following values control the tunnel 'tls'
  bishbosh_tunnelTlsCaPath       Equivalent to --tunnel-tls-ca-path
  bishbosh_tunnelTlsCaBundle     Equivalent to --tunnel-tls-ca-bundle
  bishbosh_tunnelTlsCertificate  Equivalent to --tunnel-tls-certificate
  bishbosh_tunnelTlsKey          Equivalent to --tunnel-tls-key
  bishbosh_tunnelTlsUseDer       Equivalent to --tunnel-tls-use-der
  bishbosh_tunnelTlsVerify       Equivalent to --tunnel-tls-verify
  bishbosh_tunnelTlsCiphers      Equivalent to --tunnel-tls-ciphers
  
The following values control the tunnel 'cryptcat'
  bishbosh_tunnelCryptcatPassword  Equivalent to --tunnel-cryptcat-password
  
These may also be set in the SCRIPTLETS.

The following values may be used in SCRIPTLETS to manage a connection:-
  bishbosh_connect_cleanSession  Option    Boolean
  bishbosh_connect_willTopic     Optional  String
  bishbosh_connect_willMessage   Optional  Binary*
  bishbosh_connect_willQoS       Optional  0 - 2
  bishbosh_connect_willRetain    Optional
  bishbosh_connect_keepAlive     Optional  0 - 65535
  bishbosh_connect_username      Optional  String
  bishbosh_connect_password      Optional  Binary*

  * ASCII NUL (0x00) is not supported.

The following values may be used to override client-id based configuration:-
  bishbosh_connection_clientServersPath
  bishbosh_connection_clientServersPortsPath
  bishbosh_connection_clientServersPortsClientIdsPath
  
The following handlers may be specified as functions in SCRIPTLETS, with
the globals specified:-
  bishbosh_connection_handler_CONNACK()
  bishbosh_connection_handler_SUBACK()
  bishbosh_connection_handler_UNSUBACK()
  bishbosh_connection_handler_PUBLISH()
  bishbosh_connection_handler_PUBACK()
  bishbosh_connection_handler_PUBREC()
  bishbosh_connection_handler_PUBREL()
  bishbosh_connection_handler_PUBCOMP()
  bishbosh_connection_handler_PINGRESP()
  bishbosh_connection_handler_noControlPacketsRead()
";
    _program_commandLine_helpMessage_examples="
  ${_program_name} --server test.mosquitto.org --backends nc,devtcp --client-id 12 -- /path/to/connection-details.scriptlet
"
}
_program_commandLine_optionExists () 
{ 
    case "$optionName" in 
        t | tunnel)
            echo 'yes-argumented'
        ;;
        s | server)
            echo 'yes-argumented'
        ;;
        p | port)
            echo 'yes-argumented'
        ;;
        i | client-id)
            echo 'yes-argumented'
        ;;
        r | random-client-id)
            echo 'no'
        ;;
        x | ping-timeout)
            echo 'yes-argumented'
        ;;
        w | connect-timeout)
            echo 'yes-argumented'
        ;;
        b | backends)
            echo 'yes-argumented'
        ;;
        c | clients-path)
            echo 'yes-argumented'
        ;;
        d | session-path)
            echo 'yes-argumented'
        ;;
        l | lock-path)
            echo 'yes-argumented'
        ;;
        filesize-algorithm)
            echo 'yes-argumented'
        ;;
        read-latency)
            echo 'yes-argumented'
        ;;
        transport)
            echo 'yes-argumented'
        ;;
        source-address)
            echo 'yes-argumented'
        ;;
        source-port)
            echo 'yes-argumented'
        ;;
        proxy-kind)
            echo 'yes-argumented'
        ;;
        proxy-server)
            echo 'yes-argumented'
        ;;
        proxy-port)
            echo 'yes-argumented'
        ;;
        proxy-username)
            echo 'yes-argumented'
        ;;
        proxy-password)
            echo 'yes-argumented'
        ;;
        tunnel-tls-ca-path)
            echo 'yes-argumented'
        ;;
        tunnel-tls-ca-bundle)
            echo 'yes-argumented'
        ;;
        tunnel-tls-certificate)
            echo 'yes-argumented'
        ;;
        tunnel-tls-key)
            echo 'yes-argumented'
        ;;
        tunnel-tls-use-der)
            echo 'yes-optionally-argumented'
        ;;
        tunnel-tls-verify)
            echo 'yes-optionally-argumented'
        ;;
        tunnel-tls-ciphers)
            echo 'yes-argumented'
        ;;
        tunnel-cryptcat-password)
            echo 'yes-argumented'
        ;;
        *)
            echo 'no'
        ;;
    esac
}
_program_commandLine_parseInitialise () 
{ 
    _program_default_tunnel='none';
    if core_variable_isSet bishbosh_tunnel; then
        _program_configurationSet_bishbosh_tunnel=0;
    else
        _program_configurationSet_bishbosh_tunnel=1;
    fi;
    _program_default_server='test.mosquitto.org';
    if core_variable_isSet bishbosh_server; then
        _program_configurationSet_bishbosh_server=0;
    else
        _program_configurationSet_bishbosh_server=1;
    fi;
    if core_variable_isSet bishbosh_port; then
        _program_configurationSet_bishbosh_port=0;
    else
        _program_configurationSet_bishbosh_port=1;
    fi;
    _program_default_randomClientId=0;
    if core_variable_isSet bishbosh_randomClientId; then
        _program_configurationSet_bishbosh_randomClientId=0;
    else
        _program_configurationSet_bishbosh_randomClientId=1;
    fi;
    _program_default_pingTimeout=30;
    if core_variable_isSet bishbosh_pingTimeout; then
        _program_configurationSet_bishbosh_pingTimeout=0;
    else
        _program_configurationSet_bishbosh_pingTimeout=1;
    fi;
    _program_default_connectTimeout=30;
    if core_variable_isSet bishbosh_connectTimeout; then
        _program_configurationSet_bishbosh_connectTimeout=0;
    else
        _program_configurationSet_bishbosh_connectTimeout=1;
    fi;
    _program_default_backends='openssl,socat,ncat,nc6,nc,ncDebianOpenBSD,ncFreeBSD,ncOpenBSD,ncMirBSD,ncMacOSX,ncDebianTraditional,ncSolaris,ncGNU,ncToybox,ncBusyBox,devtcp,cryptcat';
    if core_variable_isSet bishbosh_backends; then
        _program_configurationSet_bishbosh_backends=0;
    else
        _program_configurationSet_bishbosh_backends=1;
    fi;
    _program_default_clientPath="${_program_varPath}"/lib/"$_program_name"/client;
    if core_variable_isSet bishbosh_clientPath; then
        _program_configurationSet_bishbosh_clientPath=0;
    else
        _program_configurationSet_bishbosh_clientPath=1;
    fi;
    _program_default_sessionPath="${_program_varPath}"/spool/"$_program_name"/session;
    if core_variable_isSet bishbosh_sessionPath; then
        _program_configurationSet_bishbosh_sessionPath=0;
    else
        _program_configurationSet_bishbosh_sessionPath=1;
    fi;
    _program_default_lockPath="${_program_varPath}"/run/"$_program_name"/lock;
    if core_variable_isSet bishbosh_lockPath; then
        _program_configurationSet_bishbosh_lockPath=0;
    else
        _program_configurationSet_bishbosh_lockPath=1;
    fi;
    _program_default_filesizeAlgorithm=ls;
    if core_variable_isSet bishbosh_filesizeAlgorithm; then
        _program_configurationSet_bishbosh_filesizeAlgorithm=0;
    else
        _program_configurationSet_bishbosh_filesizeAlgorithm=1;
    fi;
    if [ "$core_init_shellDetected" = 'zsh' ]; then
        _program_default_readLatency=0;
    else
        _program_default_readLatency=100;
    fi;
    if core_variable_isSet bishbosh_readLatency; then
        _program_configurationSet_bishbosh_readLatency=0;
    else
        _program_configurationSet_bishbosh_readLatency=1;
    fi;
    if core_variable_isSet bishbosh_transport; then
        _program_configurationSet_bishbosh_transport=0;
    else
        _program_configurationSet_bishbosh_transport=1;
    fi;
    if core_variable_isSet bishbosh_sourceAddress; then
        _program_configurationSet_bishbosh_sourceAddress=0;
    else
        _program_configurationSet_bishbosh_sourceAddress=1;
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        _program_configurationSet_bishbosh_sourcePort=0;
    else
        _program_configurationSet_bishbosh_sourcePort=1;
    fi;
    if core_variable_isSet bishbosh_proxyKind; then
        _program_configurationSet_bishbosh_proxyKind=1;
    else
        _program_configurationSet_bishbosh_proxyKind=0;
    fi;
    if core_variable_isSet bishbosh_proxyServer; then
        _program_configurationSet_bishbosh_proxyServer=1;
    else
        _program_configurationSet_bishbosh_proxyServer=0;
    fi;
    if core_variable_isSet bishbosh_proxyPort; then
        _program_configurationSet_bishbosh_proxyPort=1;
    else
        _program_configurationSet_bishbosh_proxyPort=0;
    fi;
    if core_variable_isSet bishbosh_proxyUsername; then
        _program_configurationSet_bishbosh_proxyUsername=1;
    else
        _program_configurationSet_bishbosh_proxyUsername=0;
    fi;
    if core_variable_isSet bishbosh_proxyPassword; then
        _program_configurationSet_bishbosh_proxyPassword=1;
    else
        _program_configurationSet_bishbosh_proxyPassword=0;
    fi;
    _program_default_bishbosh_tunnelTlsUseDer=off;
    _program_default_bishbosh_tunnelTlsVerify=on
}
_program_commandLine_processOptionWithArgument () 
{ 
    case "$optionName" in 
        t | tunnel)
            bishbosh_validate_tunnel $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_tunnel="$optionValue"
        ;;
        s | server)
            bishbosh_validate_address $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_server="$optionValue"
        ;;
        p | port)
            core_validate_nonDynamicPort $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_port="$optionValue"
        ;;
        i | client-id)
            bishbosh_clientId="$optionValue"
        ;;
        x | ping-timeout)
            bishbosh_validate_unsignedIntegerUpto65535Inclusive $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_pingTimeout=$optionValue
        ;;
        w | connect-timeout)
            bishbosh_validate_unsignedIntegerUpto65535Inclusive $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_connectTimeout=$optionValue
        ;;
        b | backends)
            bishbosh_validate_backends $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_backends="$optionValue"
        ;;
        c | clients-path)
            core_validate_folderPathReadableAndSearchableAndWritable $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_clientPath="$optionValue"
        ;;
        t | session-path)
            core_validate_folderPathReadableAndSearchableAndWritable $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_sessionPath="$optionValue"
        ;;
        l | lock-path)
            core_validate_folderPathReadableAndSearchableAndWritable $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_lockPath="$optionValue"
        ;;
        filesize-algorithm)
            bishbosh_validate_filesizeAlgorithm $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_filesizeAlgorithm="$optionValue"
        ;;
        read-latency)
            bishbosh_validate_latency $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_readLatency="$optionValue"
        ;;
        transport)
            bishbosh_validate_transport $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_transport="$optionValue"
        ;;
        source-address)
            bishbosh_validate_address $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_sourceAddress="$optionValue"
        ;;
        source-port)
            core_validate_nonDynamicPort $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_sourcePort="$optionValue"
        ;;
        proxy-kind)
            bishbosh_validate_proxyKind $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_proxyKind="$optionValue";
            _program_configurationSet_bishbosh_proxyKind=0
        ;;
        proxy-server)
            bishbosh_validate_address $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_proxyServer="$optionValue";
            _program_configurationSet_bishbosh_proxyServer=0
        ;;
        proxy-port)
            core_validate_nonDynamicPort $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_proxyPort="$optionValue";
            _program_configurationSet_bishbosh_proxyPort=0
        ;;
        proxy-username)
            core_message WARN "Specifying the option '--proxy-username' on the command line is insecure";
            bishbosh_proxyUsername="$optionValue";
            _program_configurationSet_bishbosh_proxyUsername=0
        ;;
        proxy-password)
            core_message WARN "Specifying the option '--proxy-password' on the command line is insecure";
            bishbosh_proxyPassword="$optionValue";
            _program_configurationSet_bishbosh_proxyPassword=0
        ;;
        tunnel-tls-ca-path)
            core_validate_folderPathReadableAndSearchable $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_tunnelTlsCaPath="$optionValue"
        ;;
        tunnel-tls-ca-bundle)
            core_validate_filePathReadable $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_tunnelTlsCaBundle="$optionValue"
        ;;
        tunnel-tls-certificate)
            core_validate_filePathReadable $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_tunnelTlsCertificate="$optionValue"
        ;;
        tunnel-tls-key)
            core_validate_filePathReadable $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_tunnelTlsKey="$optionValue"
        ;;
        tunnel-tls-use-der)
            core_validate_isBoolean $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_tunnelTlsUseDer="$optionValue"
        ;;
        tunnel-tls-verify)
            core_validate_isBoolean $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            bishbosh_tunnelTlsVerify="$optionValue"
        ;;
        tunnel-tls-ciphers)
            bishbosh_tunnelTlsCiphers="$optionValue"
        ;;
        tunnel-cryptcat-password)
            core_message WARN "Specifying the option '--tunnel-cryptcat-password' on the command line is insecure";
            bishbosh_tunnelCryptcatPassword="$optionValue"
        ;;
    esac
}
_program_commandLine_processOptionWithoutArgument () 
{ 
    case "$optionName" in 
        r | random-client-id)
            bishbosh_randomClientId=1
        ;;
        tunnel-tls-use-der)
            bishbosh_tunnelTlsUseDer=1
        ;;
        tunnel-tls-verify)
            bishbosh_tunnelTlsVerify=1
        ;;
    esac
}
_program_commandLine_validate () 
{ 
    local categoryProxyKind;
    local nameProxyKind;
    if [ $_program_configurationSet_bishbosh_proxyKind -eq 1 ]; then
        categoryProxyKind='configuration setting';
        nameProxyKind='bishbosh_proxyKind';
    else
        categoryProxyKind='option';
        nameProxyKind='--proxy-kind';
    fi;
    local codeTransport;
    local categoryTransport;
    local nameTransport;
    if [ $_program_configurationSet_bishbosh_transport -eq 1 ]; then
        codeTransport=$core_commandLine_exitCode_CONFIG;
        categoryTransport='configuration setting';
        nameTransport='bishbosh_transport';
    else
        codeTransport=$core_commandLine_exitCode_USAGE;
        categoryTransport='option';
        nameTransport='--transport';
    fi;
    local codeServer;
    local categoryServer;
    local nameServer;
    if [ $_program_configurationSet_bishbosh_server -eq 1 ]; then
        codeServer=$core_commandLine_exitCode_CONFIG;
        categoryServer='configuration setting';
        nameServer='bishbosh_server';
    else
        codeServer=$core_commandLine_exitCode_USAGE;
        categoryServer='option';
        nameServer='--server';
    fi;
    if core_variable_isUnset bishbosh_backends; then
        bishbosh_backends="$_program_default_backends";
    else
        bishbosh_validate_backends $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_backends' "$bishbosh_backends";
    fi;
    if core_variable_isUnset bishbosh_tunnel; then
        bishbosh_tunnel="$_program_default_tunnel";
    else
        bishbosh_validate_tunnel $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_tunnel' "$bishbosh_tunnel";
    fi;
    if core_variable_isUnset bishbosh_server; then
        bishbosh_server="$_program_default_server";
    else
        bishbosh_validate_address $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_server' "$bishbosh_server";
    fi;
    if core_variable_isUnset bishbosh_randomClientId; then
        bishbosh_randomClientId=$_program_default_randomClientId;
    else
        bishbosh_validate_boolean $core_commandLine_exitCode_USAGE 'configuration setting' 'bishbosh_randomClientId' "$bishbosh_randomClientId";
    fi;
    if core_variable_isUnset bishbosh_pingTimeout; then
        bishbosh_pingTimeout=$_program_default_pingTimeout;
    else
        bishbosh_validate_unsignedIntegerUpto65535Inclusive $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_pingTimeout' "$bishbosh_pingTimeout";
    fi;
    if core_variable_isUnset bishbosh_connectTimeout; then
        bishbosh_connectTimeout=$_program_default_connectTimeout;
    else
        bishbosh_validate_unsignedIntegerUpto65535Inclusive $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_connectTimeout' "$bishbosh_connectTimeout";
    fi;
    if core_variable_isUnset bishbosh_clientPath; then
        bishbosh_clientPath="$_program_default_clientPath";
        core_validate_folderPathReadableAndSearchableAndWritable $core_commandLine_exitCode_CONFIG 'defaulted value for' '--client-path' "$bishbosh_clientPath";
    else
        core_validate_folderPathReadableAndSearchable $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_clientPath' "$bishbosh_clientPath";
    fi;
    if core_variable_isUnset bishbosh_sessionPath; then
        bishbosh_sessionPath="$_program_default_sessionPath";
        core_validate_folderPathReadableAndSearchableAndWritable $core_commandLine_exitCode_CONFIG 'defaulted value for' '--session-path' "$bishbosh_sessionPath";
    else
        core_validate_folderPathReadableAndSearchable $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_sessionPath' "$bishbosh_sessionPath";
    fi;
    if core_variable_isUnset bishbosh_lockPath; then
        bishbosh_lockPath="$_program_default_lockPath";
        core_validate_folderPathReadableAndSearchableAndWritable $core_commandLine_exitCode_CONFIG 'defaulted value for' '--lock-path' "$bishbosh_lockPath";
    else
        core_validate_folderPathReadableAndSearchable $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_lockPath' "$bishbosh_lockPath";
    fi;
    if core_variable_isUnset bishbosh_filesizeAlgorithm; then
        bishbosh_filesizeAlgorithm="$_program_default_filesizeAlgorithm";
    else
        bishbosh_validate_filesizeAlgorithm $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_filesizeAlgorithm' "$bishbosh_filesizeAlgorithm";
    fi;
    if core_variable_isUnset bishbosh_readLatency; then
        bishbosh_readLatency="$_program_default_readLatency";
    else
        bishbosh_validate_latency $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_readLatency' "$bishbosh_readLatency";
    fi;
    if core_variable_isUnset bishbosh_readLatency_inFractionalSeconds; then
        if [ $bishbosh_readLatency -lt 1 ]; then
            bishbosh_readLatency_inFractionalSeconds=0;
        else
            if [ $bishbosh_readLatency -lt 10 ]; then
                bishbosh_readLatency_inFractionalSeconds=0.00${bishbosh_readLatency};
            else
                if [ $bishbosh_readLatency -lt 100 ]; then
                    bishbosh_readLatency_inFractionalSeconds=0.0${bishbosh_readLatency};
                else
                    if [ $bishbosh_readLatency -lt 1000 ]; then
                        bishbosh_readLatency_inFractionalSeconds=0.${bishbosh_readLatency};
                    else
                        bishbosh_readLatency_inFractionalSeconds=1;
                    fi;
                fi;
            fi;
        fi;
    fi;
    if core_variable_isUnset bishbosh_transport; then
        bishbosh_transport=inet;
    else
        bishbosh_validate_transport $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_transport' "$bishbosh_transport";
        if [ "$bishbosh_transport" = unix ]; then
            if [ ! core_validate_socketPathReadableAndWritable "$bishbosh_server" ]; then
                core_exitError $codeServer "When $categoryTransport '$nameTransport' is 'unix' the $categoryServer '$nameServer' must be a path to a readable, writable domain socket ('$bishbosh_server' is not)";
            fi;
            _program_commandLine_validateTransportSetting bishbosh_sourceAddress '--source-address' 'source address' $_program_configurationSet_bishbosh_sourceAddress;
            _program_commandLine_validateTransportSetting bishbosh_sourcePort '--source-port' 'source port' $_program_configurationSet_bishbosh_sourcePort;
            _program_commandLine_validateTransportSetting bishbosh_port '-p/--port' 'destination port' $_program_configurationSet_bishbosh_port;
        fi;
        if [ "$bishbosh_transport" = serial ]; then
            if [ ! core_validate_characterDeviceFileReadableAndWritable "$bishbosh_server" ]; then
                core_exitError $codeServer "When $categoryTransport '$nameTransport' is 'serial' the $categoryServer '$nameServer' must be a path to a readable, writable character device file ('$bishbosh_server' is not)";
            fi;
            _program_commandLine_validateTransportSetting bishbosh_sourceAddress '--source-address' 'source address' $_program_configurationSet_bishbosh_sourceAddress;
            _program_commandLine_validateTransportSetting bishbosh_sourcePort '--source-port' 'source port' $_program_configurationSet_bishbosh_sourcePort;
            _program_commandLine_validateTransportSetting bishbosh_port '-p/--port' 'destination port' $_program_configurationSet_bishbosh_port;
        fi;
    fi;
    if core_variable_isSet bishbosh_proxyKind; then
        bishbosh_validate_proxyKind $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_proxyKind' "$bishbosh_proxyKind";
        if [ "$bishbosh_proxyKind" = 'none' ]; then
            _program_commandLine_validateProxySetting "'none'" bishbosh_proxyServer '--proxy-server' 'proxy server' $_program_configurationSet_bishbosh_proxyServer;
            _program_commandLine_validateProxySetting "'none'" bishbosh_proxyPort '--proxy-port' 'proxy port' $_program_configurationSet_bishbosh_proxyPort;
            _program_commandLine_validateProxySetting "'none'" bishbosh_proxyUsername '--proxy-username' 'proxy username' $_program_configurationSet_bishbosh_proxyUsername;
            _program_commandLine_validateProxySetting "'none'" bishbosh_proxyPassword '--proxy-password' 'proxy password' $_program_configurationSet_bishbosh_proxyPassword;
        else
            _program_commandLine_validateTransportSetting bishbosh_proxyKind '--proxy-kind' 'proxy kind' $_program_configurationSet_bishbosh_proxyKind;
            if core_variable_isUnset bishbosh_proxyServer; then
                core_commandLine_exitBadCommandLine "The proxy kind ($categoryProxyKind '$nameProxyKind') is '$bishbosh_proxyKind' but the option '--proxy-server' is unspecified";
            fi;
            if core_variable_isUnset bishbosh_proxyPort; then
                case "$bishbosh_proxyKind" in 
                    SOCKS4 | SOCKS4a | SOCKS5)
                        bishbosh_proxyPort=1080
                    ;;
                    HTTP)
                        bishbosh_proxyPort=3128
                    ;;
                esac;
            else
                core_validate_nonDynamicPort $core_commandLine_exitCode_USAGE 'configuration setting' 'bishbosh_proxyPort' "$bishbosh_proxyPort";
            fi;
        fi;
    else
        _program_commandLine_validateProxySetting 'unspecified' bishbosh_proxyServer '--proxy-server' 'proxy server' $_program_configurationSet_bishbosh_proxyServer;
        _program_commandLine_validateProxySetting 'unspecified' bishbosh_proxyPort '--proxy-port' 'proxy port' $_program_configurationSet_bishbosh_proxyPort;
        _program_commandLine_validateProxySetting 'unspecified' bishbosh_proxyUsername '--proxy-username' 'proxy username' $_program_configurationSet_bishbosh_proxyUsername;
        _program_commandLine_validateProxySetting 'unspecified' bishbosh_proxyPassword '--proxy-password' 'proxy password' $_program_configurationSet_bishbosh_proxyPassword;
        bishbosh_proxyKind='none';
    fi;
    if [ "$bishbosh_tunnel" = 'tls' ]; then
        if core_variable_isSet bishbosh_tunnelTlsCaBundle; then
            if core_variable_isSet bishbosh_tunnelTlsCaPath; then
                core_exitError $core_commandLine_exitCode_CONFIG "When the option '--tunnel' (or configuration setting 'bishbosh_tunnel') is '$bishbosh_tunnel', and the option '--tunnel-tls-ca-bundle' (or configuration setting 'bishbosh_tunnelTlsCaBundle') is specified, then the option '--tunnel-tls-ca-path' (or configuration setting 'bishbosh_tunnelTlsCaPath' must not be specified)";
            fi;
            core_validate_filePathReadable $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_tunnelTlsCaBundle' "$bishbosh_tunnelTlsCaBundle";
        fi;
        if core_variable_isSet bishbosh_tunnelTlsCaPath; then
            if core_variable_isSet bishbosh_tunnelTlsCaBundle; then
                core_exitError $core_commandLine_exitCode_CONFIG "When the option '--tunnel' (or configuration setting 'bishbosh_tunnel') is '$bishbosh_tunnel', and the option '--tunnel-tls-ca-path' (or configuration setting 'bishbosh_tunnelTlsCaPath') is specified, then the option '--tunnel-tls-ca-bundle' (or configuration setting 'bishbosh_tunnelTlsCaBundle' must not be specified)";
            fi;
            core_validate_folderPathReadableAndSearchable $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_tunnelTlsCaPath' "$bishbosh_tunnelTlsCaPath";
        fi;
        if core_variable_isSet bishbosh_tunnelTlsCertificate; then
            if core_variable_isUnset bishbosh_tunnelTlsKey; then
                core_exitError $core_commandLine_exitCode_CONFIG "When the option '--tunnel' (or configuration setting 'bishbosh_tunnel') is '$bishbosh_tunnel', and the option '--tunnel-tls-certificate' (or configuration setting 'bishbosh_tunnelTlsCertificate') is specified, then the option '--tunnel-tls-key' (or configuration setting 'bishbosh_tunnelTlsKey' must be specified)";
            fi;
            core_validate_filePathReadable $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_tunnelTlsCertificate' "$bishbosh_tunnelTlsCertificate";
            core_validate_filePathReadable $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_tunnelTlsKey' "$bishbosh_tunnelTlsKey";
        else
            if core_variable_isSet bishbosh_tunnelTlsKey; then
                core_exitError $core_commandLine_exitCode_CONFIG "When the option '--tunnel' (or configuration setting 'bishbosh_tunnel') is '$bishbosh_tunnel', and the option '--tunnel-tls-key' (or configuration setting 'bishbosh_tunnelTlsKey') is specified, then the option '--tunnel-tls-certificate' (or configuration setting 'bishbosh_tunnelTlsCertificate' must be specified)";
            fi;
        fi;
        if core_variable_isSet bishbosh_tunnelTlsUseDer; then
            core_validate_isBoolean $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_tunnelTlsUseDer' "$bishbosh_tunnelTlsUseDer";
        else
            bishbosh_tunnelTlsUseDer=${_program_default_bishbosh_tunnelTlsUseDer};
        fi;
        if core_variable_isSet bishbosh_tunnelTlsVerify; then
            core_validate_isBoolean $core_commandLine_exitCode_CONFIG 'configuration setting' 'bishbosh_tunnelTlsVerify' "$bishbosh_tunnelTlsVerify";
        else
            bishbosh_tunnelTlsVerify=${_program_default_bishbosh_tunnelTlsVerify};
        fi;
    else
        if core_variable_isSet bishbosh_tunnelTlsCaPath; then
            core_exitError $codeServer "When the option '--tunnel' (or configuration setting 'bishbosh_tunnel') is '$bishbosh_tunnel', then the option '--tunnel-tls-ca-path' (or configuration setting 'bishbosh_tunnelTlsCaPath') must not be specified.";
        fi;
        if core_variable_isSet bishbosh_tunnelTlsCaBundle; then
            core_exitError $codeServer "When the option '--tunnel' (or configuration setting 'bishbosh_tunnel') is '$bishbosh_tunnel', then the option '--tunnel-tls-ca-bundle' (or configuration setting 'bishbosh_tunnelTlsCaBundle') must not be specified.";
        fi;
        if core_variable_isSet bishbosh_tunnelTlsCertificate; then
            core_exitError $codeServer "When the option '--tunnel' (or configuration setting 'bishbosh_tunnel') is '$bishbosh_tunnel', then the option '--tunnel-tls-certificate' (or configuration setting 'bishbosh_tunnelTlsCertificate') must not be specified.";
        fi;
        if core_variable_isSet bishbosh_tunnelTlsKey; then
            core_exitError $codeServer "When the option '--tunnel' (or configuration setting 'bishbosh_tunnel') is '$bishbosh_tunnel', then the option '--tunnel-tls-key' (or configuration setting 'bishbosh_tunnelTlsKey') must not be specified.";
        fi;
        if core_variable_isSet bishbosh_tunnelTlsUseDer; then
            core_exitError $codeServer "When the option '--tunnel' (or configuration setting 'bishbosh_tunnel') is '$bishbosh_tunnel', then the option '--tunnel-tls-use-der' (or configuration setting 'bishbosh_tunnelTlsUseDer') must not be specified.";
        fi;
        if core_variable_isSet bishbosh_tunnelTlsVerify; then
            core_exitError $codeServer "When the option '--tunnel' (or configuration setting 'bishbosh_tunnel') is '$bishbosh_tunnel', then the option '--tunnel-tls-verify' (or configuration setting 'bishbosh_tunnelTlsVerify') must not be specified.";
        fi;
        if core_variable_isSet bishbosh_tunnelTlsCiphers; then
            core_exitError $codeServer "When the option '--tunnel' (or configuration setting 'bishbosh_tunnel') is '$bishbosh_tunnel', then the option '--tunnel-tls-ciphers' (or configuration setting 'bishbosh_tunnelTlsCiphers') must not be specified.";
        fi;
    fi;
    if [ "$bishbosh_tunnel" = 'cryptcat' ]; then
        :;
    else
        if core_variable_isSet bishbosh_tunnel_cryptcatPassword; then
            core_exitError $codeServer "When the option '--tunnel' (or configuration setting 'bishbosh_tunnel') is '$bishbosh_tunnel', then the option '--tunnel-cryptcat-password' (or configuration setting 'bishbosh_tunnelCryptcatPassword') must not be specified.";
        fi;
    fi
}
_program_commandLine_validateProxySetting () 
{ 
    local noneOrUnspecified="$1";
    local variableName="$2";
    local optionName="$3";
    local description="$4";
    local configurationSet=$5;
    local code;
    local category;
    local name;
    local message;
    if core_variable_isSet "$variableName"; then
        local core_variable_indirectValue_result;
        core_variable_indirectValue "$variableName";
        if [ $configurationSet -eq 1 ]; then
            code=$core_commandLine_exitCode_CONFIG;
            category='configuration setting';
            name="$variableName";
        else
            code=$core_commandLine_exitCode_USAGE;
            category='option';
            name="$optionName";
        fi;
        if [ $_program_configurationSet_bishbosh_proxyKind -eq 1 ]; then
            categoryProxyKind='configuration setting';
            nameProxyKind='bishbosh_proxyKind';
        else
            categoryProxyKind='option';
            nameProxyKind='--proxy-kind';
        fi;
        message="The $category '$name' specifies a $description ('$core_variable_indirectValue_result') but the proxy kind ($categoryProxyKind '$nameProxyKind') is $noneOrUnspecified";
        if [ "$noneOrUnspecified" = "unspecified" ]; then
            core_exitError $code "$message";
        else
            core_message WARN "$message";
        fi;
    fi
}
_program_commandLine_validateTransportSetting () 
{ 
    local variableName="$1";
    local optionName="$2";
    local description="$3";
    local configurationSet=$4;
    local code;
    local category;
    local name;
    if core_variable_isSet "$variableName"; then
        local core_variable_indirectValue_result;
        core_variable_indirectValue "$variableName";
        if [ $_program_configurationSet_bishbosh_transport -eq 1 ]; then
            if [ $configurationSet -eq 1 ]; then
                code=$core_commandLine_exitCode_CONFIG;
                category='configuration setting';
                name="$variableName";
            else
                code=$core_commandLine_exitCode_USAGE;
                category='option';
                name='--source-address';
            fi;
            core_exitError $code "The $category '$name' specified a $description ('$core_variable_indirectValue_result') but the transport ($categoryTransport '$nameTransport') is '$bishbosh_transport'";
        fi;
    fi
}
bishbosh () 
{ 
    bishbosh_adjustReadLatencyIfNecessary;
    bishbosh_backend_find;
    local TMP_FOLDER;
    core_temporaryFiles_newFolderToRemoveOnExit;
    local bishbosh_temporaryFolderPath="$TMP_FOLDER";
    bishbosh_connection_makeClientConnection
}
bishbosh_adjustReadLatencyIfNecessary () 
{ 
    if core_variable_isSet BASH_VERSINFO; then
        if [ ${BASH_VERSINFO[0]} -eq 3 ]; then
            if [ $bishbosh_readLatency -lt 1000 ]; then
                core_message WARN "bash 3 does not support fractional read latency (we're forcing bishbosh_readLatency to 1000 ms) [discovered on Mac OS X when run as default sh]";
                bishbosh_readLatency=1000;
                bishbosh_readLatency_inFractionalSeconds=1;
            fi;
        fi;
    fi;
    if ! core_compatibility_sleepSupportsFractionalSeconds; then
        core_message WARN "sleep does not support fractional seconds for read latency (we're forcing bishbosh_readLatency to 1000 ms) [discovered on AIX]";
        bishbosh_readLatency=1000;
        bishbosh_readLatency_inFractionalSeconds=1;
    fi
}
bishbosh_backend_cryptcat_check () 
{ 
    if [ "$bishbosh_tunnel" != 'cryptcat' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput cryptcat; then
        bishbosh_backend_name=cryptcat;
        bishbosh_backend_path="$(core_compatibility_which cryptcat)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_cryptcat_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_cryptcat_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    if core_variable_isUnset bishbosh_tunnelCryptcatPassword; then
        core_message WARN "Using cryptcat without specifying a password with the configuration setting 'bishbosh_tunnelCryptcatPassword' (or, if you must, the option '--tunnel-cryptcat-password') is insecure, as the default's 'metallica'.";
    else
        core_variable_array_append options -k "$bishbosh_tunnelCryptcatPassword";
    fi;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_debugOptions () 
{ 
    core_message DEBUG "Passing options to backend '$bishbosh_backend_name' using '$bishbosh_backend_path' as '$(core_variable_array_passToFunctionAsArguments options echo)' (please note spaces ARE handled correctly)"
}
bishbosh_backend_devtcp_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    case "$core_init_shellDetected" in 
        bash | ksh93)
            bishbosh_backend_name=devtcp;
            bishbosh_backend_path='';
            return 0
        ;;
    esac;
    return 1
}
bishbosh_backend_devtcp_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_devtcp_start () 
{ 
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support setting 'bishbosh_sourceAddress' (--source-address).";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support setting 'bishbosh_sourcePort' (--source-port).";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    exec 4<> /dev/tcp/"$bishbosh_server"/$bishbosh_port
}
bishbosh_backend_find () 
{ 
    local originalIFS="$IFS";
    local IFS=',';
    set -- $bishbosh_backends;
    local IFS="$originalIFS";
    local backendName;
    for backendName in $@;
    do
        if bishbosh_backend_${backendName}_check; then
            bishbosh_backend_name="$backendName";
            if core_variable_isUnset bishbosh_port; then
                bishbosh_port=$(bishbosh_backend_${backendName}_port);
            fi;
            if [ -n "$bishbosh_backend_path" ]; then
                core_message INFO "Using backend '$bishbosh_backend_name' (on path '$bishbosh_backend_path') with port '$bishbosh_port'";
            else
                core_message INFO "Using backend '$bishbosh_backend_name' with port '$bishbosh_port'";
            fi;
            return 0;
        fi;
    done;
    core_exitError $core_commandLine_exitCode_OSFILE "Could not find a backend to make socket connections with tunnelling '$bishbosh_tunnel' that was on the PATH '$PATH'."
}
bishbosh_backend_gnutls_check () 
{ 
    if [ "$bishbosh_tunnel" != 'tls' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput gnutls-cli; then
        bishbosh_backend_name=gnutls;
        bishbosh_backend_path="$(core_compatibility_which gnutls-cli)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_gnutls_port () 
{ 
    printf '%s' 8883
}
bishbosh_backend_gnutls_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    core_variable_array_append options --no-tofu --no-strict-tofu --no-dane --no-local-dns --noticket;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_message WARN "The backend gnutls does not support the option '--source-address' (or the configuration setting 'bishbosh_sourceAddress')";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_message WARN "The backend gnutls does not support the option '--source-port' (or the configuration setting 'bishbosh_sourcePort')";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne $_program_default_connectTimeout ]; then
        core_message WARN "The backend gnutls does not support the option '--connect-timeout' (or the configuration setting 'bishbosh_connectTimeout')";
    fi;
    if core_variable_isTrue "$bishbosh_tunnelTlsUseDer"; then
        core_variable_array_append options --x509fmtder;
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCertificate; then
        core_variable_array_append options --x509certfile="$bishbosh_tunnelTlsCertificate";
    fi;
    if core_variable_isSet bishbosh_tunnelTlsKey; then
        core_variable_array_append options --x509keyfile="$bishbosh_tunnelTlsKey";
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCaPath; then
        core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the option '--tunnel-tls-ca-path' (or configuration setting 'bishbosh_tunnelTlsCaPath').";
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCaBundle; then
        core_variable_array_append options --x509cafile "$bishbosh_tunnelTlsCaBundle";
    fi;
    if core_variable_isTrue "$bishbosh_tunnelTlsVerify"; then
        core_variable_array_append options --ocsp --ca-verification;
    else
        core_variable_array_append options --insecure --no-ocsp --no-ca-verification;
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCiphers; then
        core_variable_array_append options --priority="$bishbosh_tunnelTlsCiphers";
    fi;
    core_variable_array_append options --port="$bishbosh_port" "$bishbosh_server";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_nc6_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput nc6; then
        bishbosh_backend_name=nc6;
        bishbosh_backend_path="$(core_compatibility_which nc6)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_nc6_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_nc6_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend nc6 does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend nc6 does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend nc6 does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend nc6 does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend nc6 does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend nc6 does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options '--disable-nagle' '--half-close';
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncBusyBox_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput busybox; then
        local binary="$(core_compatibility_which busybox)";
        if $binary --list 2> /dev/null | grep -q '^nc$'; then
            bishbosh_backend_name=ncBusyBox;
            bishbosh_backend_path="$binary";
            return 0;
        fi;
    fi;
    return 1
}
bishbosh_backend_ncBusyBox_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^BusyBox v'
}
bishbosh_backend_ncBusyBox_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncBusyBox_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    core_TODO 'Allow BusyBox builtins to work by calling nc directly';
    core_variable_array_append options nc;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    case "$bishbosh_transport" in 
        inet)
            if core_variable_isSet bishbosh_sourceAddress; then
                core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support setting 'bishbosh_sourceAddress' (--source-address).";
            fi;
            if core_variable_isSet bishbosh_sourcePort; then
                core_variable_array_append options '-p' $bishbosh_sourcePort;
            fi;
            core_variable_array_append options "$bishbosh_server";
            core_variable_array_append options "$bishbosh_port"
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'unix' transport."
        ;;
        serial)
            core_variable_array_append options -f "$bishbosh_server"
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncDebianOpenBSD_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput nc.openbsd; then
        bishbosh_backend_name=ncDebianOpenBSD;
        bishbosh_backend_path="$(core_compatibility_which nc.openbsd)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_ncDebianOpenBSD_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^OpenBSD netcat '
}
bishbosh_backend_ncDebianOpenBSD_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncDebianOpenBSD_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianOpenBSD does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncDebianOpenBSD_start_addProxy '4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianOpenBSD does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncDebianOpenBSD_start_addProxy '5'
        ;;
        HTTP)
            _bishbosh_backend_ncDebianOpenBSD_start_addProxy 'connect'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncDebianTraditional_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local nameVariant;
    for nameVariant in nc.traditional netcat nc;
    do
        if core_compatibility_whichNoOutput "$nameVariant"; then
            bishbosh_backend_name=ncDebianTraditional;
            bishbosh_backend_path="$(core_compatibility_which "$nameVariant")";
            return 0;
        fi;
    done;
    return 1
}
bishbosh_backend_ncDebianTraditional_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^\[v1\.10'
}
bishbosh_backend_ncDebianTraditional_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncDebianTraditional_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncFreeBSD_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local binary;
    for binary in /usr/bin/nc "$(core_compatibility_which nc)";
    do
        if [ -z "$binary" ]; then
            continue;
        fi;
        if [ ! -x "$binary" ]; then
            continue;
        fi;
        if "$binary" -h 2>&1 | head -n 1 | grep -q -E '^usage: nc \[-46DdEhklNnrStUuvz\] \[-e policy\] \[-I length\] \[-i interval\] \[-O length\]$'; then
            bishbosh_backend_name=ncFreeBSD;
            bishbosh_backend_path="$binary";
            return 0;
        fi;
    done;
    return 1
}
bishbosh_backend_ncFreeBSD_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^usage: nc \[-46DdEhklNnrStUuvz\] \[-e policy\] \[-I length\] \[-i interval\] \[-O length\]$'
}
bishbosh_backend_ncFreeBSD_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncFreeBSD_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncFreeBSD does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncFreeBSD_start_addProxy '4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncFreeBSD does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncFreeBSD_start_addProxy '5'
        ;;
        HTTP)
            _bishbosh_backend_ncFreeBSD_start_addProxy 'connect'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncGNU_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local binary="$(core_compatibility_which nc)";
    if [ -z "$binary" ]; then
        return 1;
    fi;
    bishbosh_backend_ncGNU_checkIfNetcatVariant
}
bishbosh_backend_ncGNU_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^GNU netcat '
}
bishbosh_backend_ncGNU_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncGNU_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncMacOSX_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local binary;
    for binary in /usr/bin/nc "$(core_compatibility_which nc)";
    do
        if [ -z "$binary" ]; then
            continue;
        fi;
        if [ ! -x "$binary" ]; then
            continue;
        fi;
        if "$binary" -h 2>&1 | head -n 1 | grep -q -E '^usage: nc \[-46AcCDdFhklnrtUuvz\] \[-K tc\] \[-b boundif\] \[-i interval\] \[-p source_port\]$'; then
            bishbosh_backend_name=ncMacOSX;
            bishbosh_backend_path="$binary";
            return 0;
        fi;
    done;
    return 1
}
bishbosh_backend_ncMacOSX_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^usage: nc \[-46AcCDdFhklnrtUuvz\] \[-K tc\] \[-b boundif\] \[-i interval\] \[-p source_port\]$'
}
bishbosh_backend_ncMacOSX_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncMacOSX_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncMacOSX does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncMacOSX_start_addProxy '4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncMacOSX does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncMacOSX_start_addProxy '5'
        ;;
        HTTP)
            _bishbosh_backend_ncMacOSX_start_addProxy 'connect'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncMirBSD_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local binary;
    for binary in /usr/bin/nc "$(core_compatibility_which nc)";
    do
        if [ -z "$binary" ]; then
            continue;
        fi;
        if [ ! -x "$binary" ]; then
            continue;
        fi;
        if "$binary" -h 2>&1 | head -n 1 | grep -q -E '^usage: nc \[-46DdhIklnrStUuvz\] \[-i interval\] \[-p source_port\]$'; then
            bishbosh_backend_name=ncMirBSD;
            bishbosh_backend_path="$binary";
            return 0;
        fi;
    done;
    return 1
}
bishbosh_backend_ncMirBSD_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^usage: nc \[-46DdhIklnrStUuvz\] \[-i interval\] \[-p source_port\]$'
}
bishbosh_backend_ncMirBSD_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncMirBSD_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncMirBSD does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncMirBSD_start_addProxy '4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncMirBSD does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncMirBSD_start_addProxy '5'
        ;;
        HTTP)
            _bishbosh_backend_ncMirBSD_start_addProxy 'connect'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncOpenBSD_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local binary;
    for binary in /usr/bin/nc "$(core_compatibility_which nc)";
    do
        if [ -z "$binary" ]; then
            continue;
        fi;
        if [ ! -x "$binary" ]; then
            continue;
        fi;
        if "$binary" -h 2>&1 | head -n 1 | grep -q -E '^usage: nc \[-46DdFhklNnrStUuvz\] \[-I length\] \[-i interval\] \[-O length\]$'; then
            bishbosh_backend_name=ncOpenBSD;
            bishbosh_backend_path="$binary";
            return 0;
        fi;
    done;
    return 1
}
bishbosh_backend_ncOpenBSD_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^usage: nc \[-46DdFhklNnrStUuvz\] \[-I length\] \[-i interval\] \[-O length\]$'
}
bishbosh_backend_ncOpenBSD_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncOpenBSD_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncOpenBSD does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncOpenBSD_start_addProxy '4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncOpenBSD does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncOpenBSD_start_addProxy '5'
        ;;
        HTTP)
            _bishbosh_backend_ncOpenBSD_start_addProxy 'connect'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncSolaris_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local binary;
    for binary in /usr/bin/nc "$(core_compatibility_which nc)";
    do
        if [ -z "$binary" ]; then
            continue;
        fi;
        if [ ! -x "$binary" ]; then
            continue;
        fi;
        if "$binary" -h 2>&1 | head -n 1 | grep -q -E '^usage: nc \[-46DdEFhklnortUuvzZ\] \[-i interval\] \[-I bufsiz\] \[-O bufsiz\]$'; then
            bishbosh_backend_name=ncSolaris;
            bishbosh_backend_path="$binary";
            return 0;
        fi;
    done;
    return 1
}
bishbosh_backend_ncSolaris_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^usage: nc \[-46DdEFhklnortUuvzZ\] \[-i interval\] \[-I bufsiz\] \[-O bufsiz\]$'
}
bishbosh_backend_ncSolaris_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncSolaris_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncSolaris does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncSolaris_start_addProxy '4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncSolaris does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncSolaris_start_addProxy '5'
        ;;
        HTTP)
            _bishbosh_backend_ncSolaris_start_addProxy 'connect'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncToybox_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput uname; then
        set -- toybox toybox-"$(uname -m)";
    else
        set -- toybox;
    fi;
    local binary;
    local toyboxName;
    for toyboxName in "$@";
    do
        if core_compatibility_whichNoOutput "$toyboxName"; then
            binary="$(core_compatibility_which "$toyboxName")";
            if "$binary" 2> /dev/null | grep -q -E '^nc$| nc | nc$'; then
                bishbosh_backend_name=ncToybox;
                bishbosh_backend_path="$binary";
                return 0;
            fi;
        fi;
    done;
    return 1
}
bishbosh_backend_ncToybox_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^usage: netcat \[-tu\] '
}
bishbosh_backend_ncToybox_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncToybox_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    core_TODO 'Allow Toybox builtins to work by calling nc directly';
    core_variable_array_append options nc;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    case "$bishbosh_transport" in 
        inet)
            if core_variable_isSet bishbosh_sourceAddress; then
                core_variable_array_append options '-s' "$bishbosh_sourceAddress";
            fi;
            if core_variable_isSet bishbosh_sourcePort; then
                core_variable_array_append options '-p' "$bishbosh_sourcePort";
            fi;
            core_variable_array_append options "$bishbosh_server";
            core_variable_array_append options "$bishbosh_port"
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'unix' transport."
        ;;
        serial)
            core_variable_array_append options -f "$bishbosh_server"
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_nc_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    if ! core_compatibility_whichNoOutput nc; then
        return 1;
    fi;
    local binary="$(core_compatibility_which nc)";
    local ncVariantCheckFunction;
    for ncVariantCheckFunction in ncFreeBSD ncOpenBSD ncMirBSD ncMacOSX ncDebianOpenBSD ncSolaris ncGNU ncDebianTraditional ncToybox ncBusyBox;
    do
        if bishbosh_backend_${ncVariantCheckFunction}_checkIfNetcatVariant; then
            backendName="$ncVariantCheckFunction";
            return 0;
        fi;
    done;
    core_message WARN "Could not determine which netcat (nc, at path '$binary') you have installed.";
    return 1
}
bishbosh_backend_nc_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncat_check () 
{ 
    case "$bishbosh_tunnel" in 
        none | tls)
            :
        ;;
        *)
            return 1
        ;;
    esac;
    if core_compatibility_whichNoOutput ncat; then
        bishbosh_backend_name=ncat;
        bishbosh_backend_path="$(core_compatibility_which ncat)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_ncat_port () 
{ 
    if [ "$bishbosh_tunnel" = 'none' ]; then
        printf '%s' 1883;
    else
        if [ "$bishbosh_tunnel" = 'tls' ]; then
            printf '%s' 8883;
        else
            printf '%s' 'invalid-tunnel';
        fi;
    fi
}
bishbosh_backend_ncat_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncat does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncat_start_addProxy 'socks4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncat does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncat_start_addProxy 'socks5'
        ;;
        HTTP)
            _bishbosh_backend_ncat_start_addProxy 'http'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        2)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    if [ "$bishbosh_tunnel" = 'tls' ]; then
        if core_variable_isSet bishbosh_tunnelTlsCaPath; then
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncat does not support the option '--tunnel-tls-ca-path' (or configuration setting 'bishbosh_tunnelTlsCaPath').";
        fi;
        if core_variable_isTrue "$bishbosh_tunnelTlsUseDer"; then
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncat does not support DER certificates and keys.";
        fi;
        core_variable_array_append options --ssl;
        if core_variable_isSet bishbosh_tunnelTlsCertificate; then
            core_variable_array_append options --ssl-cert "$bishbosh_tunnelTlsCertificate";
        fi;
        if core_variable_isSet bishbosh_tunnelTlsKey; then
            core_variable_array_append options --ssl-key "$bishbosh_tunnelTlsKey";
        fi;
        if core_variable_isSet bishbosh_tunnelTlsCaBundle; then
            core_variable_array_append options --ssl-trustfile "$bishbosh_tunnelTlsCaBundle";
        fi;
        if core_variable_isTrue "$bishbosh_tunnelTlsVerify"; then
            core_variable_array_append options --ssl-verify;
        fi;
        if core_variable_isSet bishbosh_tunnelTlsCiphers; then
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncat does not support the option '--tunnel-tls-ciphers' (or configuration setting 'bishbosh_tunnelTlsCiphers').";
        fi;
    fi;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_netcatVariantHelpMessageLineExists () 
{ 
    local pattern="$1";
    if core_compatibility_whichNoOutput sed; then
        local result="$("$binary" -h 2>&1 | sed -n "/${pattern}/=")";
        if [ "$result" = '1' ]; then
            bishbosh_backend_path="$binary";
            return 0;
        fi;
        return 1;
    fi;
    if core_compatibility_whichNoOutput grep; then
        if core_compatibility_whichNoOutput head; then
            if "$binary" -h 2>&1 | head -n 1 | grep -q -E "$pattern"; then
                bishbosh_backend_path="$binary";
                return 0;
            fi;
        fi;
        return 1;
    fi;
    core_exitError $core_commandLine_exitCode_OSFILE "Either 'sed' or 'grep' and 'head' must be present to use the 'nc' meta-backend."
}
bishbosh_backend_openssl_check () 
{ 
    if [ "$bishbosh_tunnel" != 'tls' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput openssl; then
        bishbosh_backend_name=openssl;
        bishbosh_backend_path="$(core_compatibility_which openssl)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_openssl_port () 
{ 
    printf '%s' 8883
}
bishbosh_backend_openssl_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    core_variable_array_append options s_client -bugs -quiet;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_message WARN "The backend openssl does not support the option '--source-address' (or the configuration setting 'bishbosh_sourceAddress')";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_message WARN "The backend openssl does not support the option '--source-port' (or the configuration setting 'bishbosh_sourcePort')";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne $_program_default_connectTimeout ]; then
        core_message WARN "The backend openssl does not support the option '--connect-timeout' (or the configuration setting 'bishbosh_connectTimeout')";
    fi;
    local disableNoisyStdErr;
    case $(core_init_verbosity) in 
        0)
            disableNoisyStdErr=1
        ;;
        *)
            disableNoisyStdErr=0;
            core_variable_array_append options -state
        ;;
    esac;
    local encoding;
    if core_variable_isTrue "$bishbosh_tunnelTlsUseDer"; then
        encoding=DER;
    else
        encoding=PEM;
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCertificate; then
        core_variable_array_append options -cert "$bishbosh_tunnelTlsCertificate" -certform "$encoding";
    fi;
    if core_variable_isSet bishbosh_tunnelTlsKey; then
        core_variable_array_append options -key "$bishbosh_tunnelTlsKey" -keyform "$encoding";
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCaPath; then
        core_variable_array_append options -CApath "$bishbosh_tunnelTlsCaPath";
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCaBundle; then
        core_variable_array_append options -CAfile "$bishbosh_tunnelTlsCaBundle";
    fi;
    if core_variable_isTrue "$bishbosh_tunnelTlsVerify"; then
        core_variable_array_append options -verify 5;
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCiphers; then
        core_variable_array_append options -cipher "$bishbosh_tunnelTlsCiphers";
    fi;
    core_variable_array_append options -connect "$bishbosh_server":"$bishbosh_port";
    core_variable_array_append options -no_ticket;
    bishbosh_backend_debugOptions;
    if [ $disableNoisyStdErr -eq 1 ]; then
        core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" 2> /dev/null &
    else
        core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
    fi
}
bishbosh_backend_socat_check () 
{ 
    case "$bishbosh_tunnel" in 
        none | tls)
            :
        ;;
        *)
            return 1
        ;;
    esac;
    if core_compatibility_whichNoOutput socat; then
        bishbosh_backend_name=socat;
        bishbosh_backend_path="$(core_compatibility_which socat)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_socat_port () 
{ 
    if [ "$bishbosh_tunnel" = 'none' ]; then
        printf '%s' 1883;
    else
        if [ "$bishbosh_tunnel" = 'tls' ]; then
            printf '%s' 8883;
        else
            printf '%s' 'invalid-tunnel';
        fi;
    fi
}
bishbosh_backend_socat_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    core_variable_array_append options -ls;
    core_variable_array_append options -lp${_program_name};
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -d
        ;;
        2)
            core_variable_array_append options -d -d
        ;;
        3)
            core_variable_array_append options -d -d -d
        ;;
        4)
            core_variable_array_append options -d -d -d -d
        ;;
    esac;
    case "$bishbosh_transport" in 
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
    esac;
    core_variable_array_append options 'STDIO';
    case "$bishbosh_transport" in 
        unix)
            if [ "$bishbosh_tunnel" = 'tls' ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The backend socat does not support the 'unix' transport when the tunnel is 'tls'";
            fi;
            core_variable_array_append options "UNIX-CONNECT:${bishbosh_server}";
            core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
        ;;
        serial)
            if [ "$bishbosh_tunnel" = 'tls' ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The backend socat does not support the 'serial' transport when the tunnel is 'tls'";
            fi;
            core_variable_array_append options "${bishbosh_server},raw,echo=0";
            core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
        ;;
        inet*)
            local addressKind;
            case "$bishbosh_proxyKind" in 
                SOCKS4 | SOCKS4a)
                    if [ "$bishbosh_tunnel" = 'tls' ]; then
                        core_exitError $core_commandLine_exitCode_CONFIG "The backend socat does not support the '$bishbosh_proxyKind' proxy kind when the tunnel is 'tls'";
                    fi;
                    addressKind="${$bishbosh_proxyKind}:${bishbosh_proxyAddress}:${bishbosh_server}:${bishbosh_port}";
                    if core_variable_isSet bishbosh_proxyPort; then
                        addressKind="${addressKind},socksport=${bishbosh_proxyPort}";
                    fi;
                    if core_variable_isSet bishbosh_proxyUsername; then
                        addressKind="${addressKind},socksuser=${bishbosh_proxyUsername}";
                    fi;
                    if core_variable_isSet bishbosh_proxyPassword; then
                        core_message WARN "The backend socat does not support specifing the proxy password for 'SOCKS4' bishbosh_proxyKind.";
                    fi
                ;;
                SOCKS5)
                    core_exitError $core_commandLine_exitCode_CONFIG "The backend socat does not support the 'SOCKS5' bishbosh_proxyKind."
                ;;
                HTTP)
                    if [ "$bishbosh_tunnel" = 'tls' ]; then
                        core_exitError $core_commandLine_exitCode_CONFIG "The backend socat does not support the '$bishbosh_proxyKind' proxy kind when the tunnel is 'tls'";
                    fi;
                    addressKind="PROXY:${bishbosh_proxyAddress}:${bishbosh_server}:${bishbosh_port}";
                    if core_variable_isSet bishbosh_proxyPort; then
                        addressKind="${addressKind},socksport=${bishbosh_proxyPort}";
                    fi;
                    if core_variable_isSet bishbosh_proxyUsername; then
                        if core_variable_isSet bishbosh_proxyPassword; then
                            addressKind="${addressKind},proxyauth=${bishbosh_proxyUsername}:${bishbosh_proxyPassword}";
                        else
                            core_message WARN $core_commandLine_exitCode_CONFIG "The backend socat requires 'bishbosh_proxyUsername' and 'bishbosh_proxyPassword' for the 'HTTP' bishbosh_proxyKind.";
                        fi;
                    else
                        if core_variable_isSet bishbosh_proxyPassword; then
                            core_message WARN $core_commandLine_exitCode_CONFIG "The backend socat requires 'bishbosh_proxyUsername' and 'bishbosh_proxyPassword' for the 'HTTP' bishbosh_proxyKind.";
                        fi;
                    fi
                ;;
                *)
                    if [ "$bishbosh_tunnel" = 'tls' ]; then
                        if core_variable_isTrue "$bishbosh_tunnelTlsUseDer"; then
                            core_exitError $core_commandLine_exitCode_CONFIG "The backend socat does not support DER certificates and keys.";
                        fi;
                        addressKind="OPENSSL:${bishbosh_server}:${bishbosh_port},compress=none";
                        if core_variable_isSet bishbosh_tunnelTlsCertificate; then
                            addressKind="${addressKind},cert=$bishbosh_tunnelTlsCertificate";
                        fi;
                        if core_variable_isSet bishbosh_tunnelTlsKey; then
                            addressKind="${addressKind},key=$bishbosh_tunnelTlsKey";
                        fi;
                        if core_variable_isSet bishbosh_tunnelTlsCaFile; then
                            addressKind="${addressKind},file=$bishbosh_tunnelTlsCaFile";
                        fi;
                        if core_variable_isSet bishbosh_tunnelTlsCaBundle; then
                            addressKind="${addressKind},capath=$bishbosh_tunnelTlsCaBundle";
                        fi;
                        if core_variable_isTrue "$bishbosh_tunnelTlsVerify"; then
                            addressKind="${addressKind},verify=1";
                        else
                            addressKind="${addressKind},verify=0";
                        fi;
                        if core_variable_isSet bishbosh_tunnelTlsCiphers; then
                            addressKind="${addressKind},cipher=$bishbosh_tunnelTlsCiphers";
                        fi;
                    else
                        case "$bishbosh_transport" in 
                            inet)
                                addressKind='TCP'
                            ;;
                            inet4)
                                addressKind='TCP4'
                            ;;
                            inet6)
                                addressKind='TCP6'
                            ;;
                        esac;
                        addressKind="${addressKind}:${bishbosh_server}:${bishbosh_port}";
                    fi
                ;;
            esac;
            local binding;
            if core_variable_isSet bishbosh_sourceAddress; then
                binding=",bind=$bishbosh_sourceAddress";
                if core_variable_isSet bishbosh_sourcePort; then
                    binding="${binding}:${bishbosh_sourcePort}";
                fi;
            else
                if core_variable_isSet bishbosh_sourcePort; then
                    binding=",sourceport=${bishbosh_sourcePort}";
                fi;
            fi;
            local connectTimeout;
            if [ $bishbosh_connectTimeout -ne 0 ]; then
                connectTimeout=",connect-timeout=${bishbosh_connectTimeout}";
            else
                connectTimeout='';
            fi;
            core_variable_array_append options "${addressKind}${binding}${connectTimeout},keepalive,linger=1,nodelay"
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_connection_background_client () 
{ 
    bishbosh_backend_${bishbosh_backend_name}_start
}
bishbosh_connection_background_hexConversion () 
{ 
    if core_compatibility_whichNoOutput uname; then
        if [ "$(uname)" = 'AIX' ]; then
            local odConversionString='d1';
        else
            local odConversionString='u1';
        fi;
    else
        local odConversionString='u1';
    fi;
    while true; do
        local unbufferingTool;
        for unbufferingTool in gstdbuf stdbuf;
        do
            if ! core_compatibility_whichNoOutput "$unbufferingTool"; then
                continue;
            fi;
            local odTool;
            for odTool in god od;
            do
                if ! core_compatibility_whichNoOutput "$odTool"; then
                    continue;
                fi;
                if ! "$odTool" --version 2>&1 | grep -q '^od (GNU coreutils) '; then
                    continue;
                fi;
                core_message INFO "Using stdbuf ($unbufferingTool) with od ($odTool)";
                set -- "$unbufferingTool" -i 0 -o 0 -e 0 "$odTool" -A n -t "$odConversionString" -w1 -v;
                break 3;
            done;
        done;
        if core_compatibility_whichNoOutput hexdump; then
            core_message INFO "Using hexdump";
            set -- _bishbosh_connection_background_hexConversion_dd_hexdump -e '/1 "%u\n"';
            break;
        fi;
        if core_compatibility_whichNoOutput od; then
            core_message INFO "Using od with conversion '$odConversionString'";
            set -- _bishbosh_connection_background_hexConversion_dd_od -A n -t "$odConversionString";
            break;
        fi;
        if core_compatibility_whichNoOutput unbuffer; then
            if core_compatibility_whichNoOutput hexdump; then
                core_message INFO "Using unbuffer with hexdump";
                set -- unbuffer hexdump -v -e '/1 "%u\n"';
                break;
            else
                local odTool;
                for odTool in god od;
                do
                    if ! core_compatibility_whichNoOutput "$odTool"; then
                        continue;
                    fi;
                    if ! "$odTool" --version 2>&1 | grep -q '^od (GNU coreutils) '; then
                        continue;
                    fi;
                    core_message INFO "Using unbuffer with od ($odTool)";
                    set -- unbuffer "$odTool" -A n -t "$odConversionString" -w1 -v;
                    break 2;
                done;
            fi;
        fi;
        core_exitError $core_commandLine_exitCode_OSFILE "Could not find a means of doing Hex Conversion";
    done;
    if [ "${bishbosh_backend_name}" = 'devtcp' ]; then
        "$@" 0<&4 > "$bishbosh_connection_fromHexConversionFifo" &
    else
        "$@" < "$bishbosh_connection_fromServerFifo" > "$bishbosh_connection_fromHexConversionFifo" &
    fi
}
bishbosh_connection_background_processLoop () 
{ 
    _bishbosh_connection_background_processLoop_body () 
    { 
        trap '' TERM INT HUP ABRT QUIT;
        bishbosh_connection_continue=true;
        trap _bishbosh_connection_background_processLoop_trapHandlerTERM TERM;
        bishbosh_connection_read_byte_nonBlockingInitialise;
        if ! $bishbosh_connection_continue; then
            return;
        fi;
        core_message INFO "Writing CONNECT";
        bishbosh_connection_write_CONNECT;
        local controlPacketByte;
        local remainingLength;
        while $bishbosh_connection_continue; do
            controlPacketByte='';
            bishbosh_connection_read_byte_nonBlocking controlPacketByte;
            if [ -z "$controlPacketByte" ]; then
                continue;
            fi;
            break;
        done;
        if ! $bishbosh_connection_continue; then
            return;
        fi;
        if [ $controlPacketByte -ne 32 ]; then
            bishbosh_connection_read_controlpacket_invalid;
        fi;
        bishbosh_connection_read_remainingLength CONNACK;
        bishbosh_connection_read_controlpacket_CONNACK;
        core_message INFO "Received valid CONNACK";
        while $bishbosh_connection_continue; do
            bishbosh_connection_ping_sendPingIfRequired;
            controlPacketByte='';
            bishbosh_connection_read_byte_nonBlocking controlPacketByte;
            if [ -z "$controlPacketByte" ]; then
                bishbosh_connection_ping_checkForResponseTimeout;
                bishbosh_connection_handler_noControlPacketsRead;
                continue;
            fi;
            bishbosh_connection_read_remainingLength "$controlPacketByte";
            bishbosh_connection_read_controlpacket_handle;
            bishbosh_connection_ping_checkForResponseTimeout;
        done;
        core_message INFO "Writing DISCONNECT";
        trap _bishbosh_connection_background_processLoop_trapHandlerPIPE PIPE;
        bishbosh_connection_write_DISCONNECT
    };
    if [ "${bishbosh_backend_name}" = 'devtcp' ]; then
        _bishbosh_connection_background_processLoop_body 1>&4 3< "$bishbosh_connection_fromHexConversionFifo" &
    else
        _bishbosh_connection_background_processLoop_body > "$bishbosh_connection_toServerFifo" 3< "$bishbosh_connection_fromHexConversionFifo" &
    fi
}
bishbosh_connection_background_processingLoopReadInterrupter () 
{ 
    if [ $bishbosh_connection_supportsNonBlockingRead -eq 0 ]; then
        { 
            trap '' TERM INT HUP ABRT QUIT USR1 USR2;
            bishbosh_connection_background_processingLoopReadInterrupter_trapHandler () 
            { 
                bishbosh_connection_background_processingLoopReadInterrupter_continue=false
            };
            bishbosh_connection_background_processingLoopReadInterrupter_continue=true;
            trap bishbosh_connection_background_processingLoopReadInterrupter_trapHandler TERM;
            while $bishbosh_connection_background_processingLoopReadInterrupter_continue; do
                sleep $bishbosh_readLatency_inFractionalSeconds;
                kill -HUP $bishbosh_connection_processLoopPid 2> /dev/null || exit 0;
            done
        } > /dev/null < /dev/null & bishbosh_connection_foreground_recordBackgroundJob bishbosh_connection_processingLoopReadInterrupterPid;
    fi
}
bishbosh_connection_cleanContentsOfFolderPath () 
{ 
    set +f;
    rm -rf "$1"/* 2> /dev/null;
    set -f
}
bishbosh_connection_clientId_random () 
{ 
    local potentialClientId;
    local reducedClientId;
    while true; do
        potentialClientId="$(bishbosh_connection_clientId_randomBytesBase64EncodedALike 16)";
        reducedClientId="$(bishbosh_connection_validate_removeCharacters '+/' "$potentialClientId")";
        if [ ${#reducedClientId} = ${#potentialClientId}]; then
            bishbosh_clientId="$potentialClientId";
            return 0;
        fi;
    done
}
bishbosh_connection_clientId_randomBytesBase64EncodedALike () 
{ 
    local count=$1;
    if core_compatibility_whichNoOutput openssl; then
        openssl -base64 $count;
        return 0;
    fi;
    if core_compatibility_whichNoOutput gpg; then
        gpg --armor --gen-random 1 $count;
        return 0;
    fi;
    if core_compatibility_whichNoOutput base64; then
        if core_compatibility_whichNoOutput tr; then
            local randomFilePath;
            for randomFilePath in /dev/urandom /dev/random;
            do
                if [ -r "$randomFilePath" ]; then
                    if core_compatibility_whichNoOutput dd; then
                        dd bs=1 count=$count if="$randomFilePath" | bishbosh_connection_clientId_randomBytesBase64EncodedALike_base64tr;
                        return 0;
                    fi;
                    if core_compatibility_whichNoOutput head; then
                        head -c $count | bishbosh_connection_clientId_randomBytesBase64EncodedALike_base64tr;
                        return 0;
                    fi;
                fi;
            done;
            if core_variable_isSet RANDOM; then
                { 
                    local index;
                    while [ $index -lt $count ]; do
                        printf "\\$(printf '%o' $((RANDOM%256)))";
                        index=$((index+1));
                    done
                } | bishbosh_connection_clientId_randomBytesBase64EncodedALike_base64tr;
                return 0;
            fi;
            if core_compatibility_whichNoOutput awk; then
                { 
                    local index;
                    while [ $index -lt $count ]; do
                        printf "\\$(printf '%o' $(echo | awk -v ORS='' '{ srand(); print int((rand()*1000000)%256)} '))";
                        index=$((index+1));
                    done
                } | bishbosh_connection_clientId_randomBytesBase64EncodedALike_base64tr;
                return 0;
            fi;
        fi;
    fi;
    core_message WARN "Clean Session is 1, the client id is unset and there are not sources of randomness; defaulting to empty (''). This may be rejected by some MQTT servers.";
    bishbosh_clientId=''
}
bishbosh_connection_clientId_randomBytesBase64EncodedALike_base64tr () 
{ 
    base64 | tr -d '\n='
}
bishbosh_connection_clientId_validateAndDefault () 
{ 
    if core_variable_isSet bishbosh_clientId; then
        bishbosh_connection_validate_clientId;
        return 0;
    fi;
    if core_variable_isUnset bishbosh_connect_cleanSession; then
        core_exitError $core_commandLine_exitCode_CONFIG "Clean Session is 0 and the option -i,--client-id or configuration setting bishbosh_clientId isn't set, either in configuration, SCRIPTLETS or any path under '$bishbosh_clientPath'.";
    else
        core_validate_isBoolean $core_commandLine_exitCode_CONFIG 'configuration setting' bishbosh_connect_cleanSession "$bishbosh_connect_cleanSession";
        if core_variable_isFalse "$bishbosh_connect_cleanSession"; then
            core_exitError $core_commandLine_exitCode_CONFIG "Clean Session is 0 and the option -i,--client-id or configuration setting bishbosh_clientId isn't set, either in configuration, SCRIPTLETS or any path under '$bishbosh_clientPath'.";
        fi;
    fi;
    if core_variable_isTrue bishbosh_randomClientId; then
        bishbosh_connection_clientId_random;
    else
        core_message WARN "Clean Session is 1 and the client id is unset; defaulting to empty (''). This may be rejected by some MQTT servers.";
        bishbosh_clientId='';
    fi
}
bishbosh_connection_createFifos () 
{ 
    bishbosh_connection_fifoFolder="$(bishbosh_connection_mkdir "$bishbosh_temporaryFolderPath"/"$bishbosh_connection_id" fifo)";
    bishbosh_connection_toServerFifo="$(bishbosh_connection_mkfifo to-server)";
    bishbosh_connection_fromServerFifo="$(bishbosh_connection_mkfifo from-server)";
    bishbosh_connection_fromHexConversionFifo="$(bishbosh_connection_mkfifo from-hex-conversion)"
}
bishbosh_connection_error_any () 
{ 
    local exitCode=$1;
    local message="$2";
    core_exitError $exitCode "Connection:$bishbosh_connection_id:$message"
}
bishbosh_connection_error_connectReturnCode () 
{ 
    local exitCode=$1;
    local message="$2";
    bishbosh_connection_error_any $exitCode "CONNACK:read:$message"
}
bishbosh_connection_error_ifRemainingLengthNot () 
{ 
    local controlPacket="$1";
    local expectedLength=$2;
    if [ $remainingLength -ne $expectedLength ]; then
        bishbosh_connection_error_protocolReadControlPacket "$controlPacket" "Remaining length '$remainingLength' should be $expectedLength";
    fi
}
bishbosh_connection_error_ifRemainingLengthNotZero () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot "$1" 0
}
bishbosh_connection_error_pingTimeout () 
{ 
    bishbosh_connection_error_any $core_commandLine_exitCode_UNAVAILABLE "ping:timeout"
}
bishbosh_connection_error_protocol () 
{ 
    local message="$1";
    bishbosh_connection_error_any $core_commandLine_exitCode_PROTOCOL "$message"
}
bishbosh_connection_error_protocolRead () 
{ 
    local message="$1";
    bishbosh_connection_error_protocol "read:$message"
}
bishbosh_connection_error_protocolReadControlPacket () 
{ 
    local controlPacket="$1";
    local message="$2";
    bishbosh_connection_error_protocolRead "$controlPacket:$message"
}
bishbosh_connection_error_unknownPacketIdentifier () 
{ 
    bishbosh_connection_error_protocolReadControlPacket "$1" "Unknown packet identifier '$packetIdentifier'"
}
bishbosh_connection_foreground_initialise () 
{ 
    bishbosh_connection_foreground_monitorForChildExit=0;
    trap '' INT HUP TERM ABRT QUIT;
    trap _bishbosh_connection_foreground_trapHandlerMost HUP TERM ABRT QUIT;
    trap _bishbosh_connection_foreground_trapHandlerINT INT
}
bishbosh_connection_foreground_monitorForChildExit () 
{ 
    core_message DEBUG "Our Pid is $$";
    core_message NOTICE "Terminate ${_program_name} with $(core_terminal_effect 2 reversed) kill $$ ";
    while true; do
        if [ $bishbosh_connection_foreground_monitorForChildExit -gt 0 ]; then
            kill $bishbosh_connection_processLoopPid 2> /dev/null || true;
            set +e;
            wait $bishbosh_connection_processLoopPid;
            local exitCode=$?;
            set -e;
            if [ $bishbosh_connection_foreground_monitorForChildExit -eq 2 ]; then
                kill -INT $$ 2> /dev/null || true;
                exit 1;
            else
                if [ $exitCode -ne 0 ]; then
                    core_exitError $exitCode "terminated by TERM, HUP, ABRT or QUIT";
                else
                    exit 0;
                fi;
            fi;
        fi;
        if ! kill -0 $bishbosh_connection_processLoopPid 2> /dev/null; then
            set +e;
            wait $bishbosh_connection_processLoopPid;
            local exitCode=$?;
            set -e;
            if [ $exitCode -ne 0 ]; then
                core_exitError $exitCode "processLoop failed";
            fi;
            exit 0;
        fi;
        if [ $bishbosh_connection_clientPid -ne -1 ]; then
            if ! kill -0 $bishbosh_connection_clientPid 2> /dev/null; then
                set +e;
                wait $bishbosh_connection_clientPid;
                local exitCode=$?;
                set -e;
                if [ $exitCode -ne 0 ]; then
                    core_exitError $core_commandLine_exitCode_TEMPFAIL "Could not connect to '$bishbosh_server'";
                fi;
                exit 0;
            fi;
        fi;
        sleep "$bishbosh_readLatency_inFractionalSeconds";
    done
}
bishbosh_connection_foreground_recordBackgroundJob () 
{ 
    local pidName="$1";
    local pid=$!;
    core_variable_setVariable "$pidName" $pid;
    core_children_killOnExit $pid;
    core_message DEBUG "$pidName is $pid"
}
bishbosh_connection_handler_CONNACK () 
{ 
    core_message DEBUG "bishbosh_connection_handler_CONNACK(bishbosh_connection_sessionPresent=$bishbosh_connection_sessionPresent)"
}
bishbosh_connection_handler_PINGRESP () 
{ 
    core_message DEBUG "bishbosh_connection_handler_PINGRESP()"
}
bishbosh_connection_handler_PUBACK () 
{ 
    core_message DEBUG "bishbosh_connection_handler_PUBACK(packetIdentifier=$packetIdentifier, unknownPacketIdentifier=$packetIdentifier)"
}
bishbosh_connection_handler_PUBCOMP () 
{ 
    core_message DEBUG "bishbosh_connection_handler_PUBCOMP(packetIdentifier=$packetIdentifier, unknownPacketIdentifier=$packetIdentifier)"
}
bishbosh_connection_handler_PUBLISH () 
{ 
    core_message DEBUG "bishbosh_connection_handler_PUBLISH(packetIdentifier=$packetIdentifier, retain=$retain, QoS=$QoS, dup=$dup, topicLength=$topicLength, topicName=$topicName, topicNameFilePath="$topicNameFilePath", messageLength=$messageLength, messageFilePath=$messageFilePath)";
    rm "$messageFilePath"
}
bishbosh_connection_handler_PUBLISH_again () 
{ 
    core_message DEBUG "bishbosh_connection_handler_PUBLISH_again(packetIdentifier=$packetIdentifier, retain=$retain, QoS=$QoS, dup=$dup, topicLength=$topicLength, topicName=$topicName, topicNameFilePath="$topicNameFilePath", messageLength=$messageLength, messageFilePath=$messageFilePath)";
    rm "$messageFilePath"
}
bishbosh_connection_handler_PUBREC () 
{ 
    core_message DEBUG "bishbosh_connection_handler_PUBREC(packetIdentifier=$packetIdentifier, unknownPacketIdentifier=$packetIdentifier)"
}
bishbosh_connection_handler_PUBREL () 
{ 
    core_message DEBUG "bishbosh_connection_handler_PUBREL(packetIdentifier=$packetIdentifier, unknownPacketIdentifier=$packetIdentifier)"
}
bishbosh_connection_handler_SUBACK () 
{ 
    core_message DEBUG "bishbosh_connection_handler_SUBACK(packetIdentifier=$packetIdentifier, returnCodeCount=$returnCodeCount, returnCodes=$@)"
}
bishbosh_connection_handler_UNSUBACK () 
{ 
    core_message DEBUG "bishbosh_connection_handler_UNSUBACK(packetIdentifier=$packetIdentifier)"
}
bishbosh_connection_handler_noControlPacketsRead () 
{ 
    if core_variable_isUnset _bishbosh_connection_handler_noControlPacketsRead_count; then
        _bishbosh_connection_handler_noControlPacketsRead_count=1;
    fi;
    if [ $_bishbosh_connection_handler_noControlPacketsRead_count -eq 10 ]; then
        core_message DEBUG "bishbosh_connection_handler_noControlPacketsRead() 10 times";
        _bishbosh_connection_handler_noControlPacketsRead_count=1;
    else
        _bishbosh_connection_handler_noControlPacketsRead_count=$((_bishbosh_connection_handler_noControlPacketsRead_count+1));
    fi
}
bishbosh_connection_makeClientConnection () 
{ 
    bishbosh_connection_validate_initialise;
    if core_variable_isUnset bishbosh_connection_clientServersPath; then
        bishbosh_connection_clientServersPath="$bishbosh_clientPath"/servers/"$bishbosh_server";
        bishbosh_connection_sourceScriptlets "$bishbosh_connection_clientServersPath";
    fi;
    if core_variable_isUnset bishbosh_connection_clientServersPortsPath; then
        bishbosh_connection_clientServersPortsPath="$bishbosh_connection_clientServersPath"/ports/"$bishbosh_port";
        bishbosh_connection_sourceScriptlets "$bishbosh_connection_clientServersPortsPath";
    fi;
    bishbosh_connection_clientId_validateAndDefault;
    if core_variable_isUnset bishbosh_connection_clientServersPortsClientIdsPath; then
        bishbosh_connection_clientServersPortsClientIdsPath="$bishbosh_connection_clientServersPortsPath"/client-ids/_"$bishbosh_clientId";
        bishbosh_connection_sourceScriptlets "$bishbosh_connection_clientServersPortsClientIdsPath";
    fi;
    bishbosh_connection_obtainLockForClientId;
    bishbosh_connection_obtainConnectionId;
    bishbosh_connection_createFifos;
    bishbosh_connection_packetIdentifier_initialise;
    bishbosh_connection_write_initialise;
    bishbosh_connection_read_initialise 'no';
    bishbosh_connection_ping_initialise;
    bishbosh_connection_foreground_initialise;
    bishbosh_connection_background_client;
    if [ "${bishbosh_backend_name}" = 'devtcp' ]; then
        bishbosh_connection_clientPid=-1;
    else
        bishbosh_connection_foreground_recordBackgroundJob bishbosh_connection_clientPid;
    fi;
    bishbosh_connection_background_hexConversion;
    bishbosh_connection_foreground_recordBackgroundJob bishbosh_connection_hexConversionPid;
    bishbosh_connection_background_processLoop;
    bishbosh_connection_foreground_recordBackgroundJob bishbosh_connection_processLoopPid;
    bishbosh_connection_background_processingLoopReadInterrupter;
    bishbosh_connection_foreground_monitorForChildExit
}
bishbosh_connection_mkdir () 
{ 
    local parentPath="$1";
    local folderName="$2";
    local folderPath="$parentPath"/"$folderName";
    mkdir -m 0700 -p "$folderPath";
    printf '%s' "$folderPath"
}
bishbosh_connection_mkfifo () 
{ 
    local fifoName="$1";
    local fifoPath="$bishbosh_connection_fifoFolder"/"$fifoName";
    if core_compatibility_whichNoOutput mkfifo; then
        mkfifo -m 0600 "$fifoPath";
    else
        if core_compatibility_whichNoOutput mknod; then
            mknod -m 0600 "$fifoPath" p;
        fi;
    fi;
    printf '%s' "$fifoPath"
}
bishbosh_connection_obtainConnectionId () 
{ 
    if core_variable_isUnset bishbosh_connection_nextId; then
        bishbosh_connection_id=0;
        bishbosh_connection_nextId=0;
    else
        bishbosh_connection_id=$bishbosh_connection_nextId;
        bishbosh_connection_nextId=$((bishbosh_connection_nextId + 1));
    fi
}
bishbosh_connection_obtainLockForClientId () 
{ 
    bishbosh_connection_clientIdLockFolderPath='';
    _bishbosh_connection_write_removeClientIdLockFolder () 
    { 
        if [ -n "$bishbosh_connection_clientIdLockFolderPath" ]; then
            rmdir "$bishbosh_connection_clientIdLockFolderPath" > /dev/null 2> /dev/null || true;
        fi
    };
    core_trap_addOnCleanUp _bishbosh_connection_write_removeClientIdLockFolder;
    local lockPath="$bishbosh_lockPath"/servers/"$bishbosh_server"/ports/"$bishbosh_port"/client-ids/"_${bishbosh_clientId}"/lock;
    if mkdir -m 0755 -p "$lockPath"; then
        bishbosh_connection_clientIdLockFolderPath="$lockPath";
    else
        core_exitError $core_commandLine_exitCode_TEMPFAIL "Another process has lock'd Client Id '$bishbosh_clientId' at path '$lockPath'";
    fi
}
bishbosh_connection_packetIdentifier_incrementTransmissionCounter () 
{ 
    local packetIdentifierFolderPath="$1";
    local transmissionCounter=$bishbosh_connection_packetIdentifier_transmissionCounter;
    bishbosh_connection_packetIdentifier_transmissionCounter=$((bishbosh_connection_packetIdentifier_transmissionCounter+1));
    printf '%s' "$transmissionCounter" > "$packetIdentifierFolderPath"/transmission-counter
}
bishbosh_connection_packetIdentifier_initialise () 
{ 
    if core_variable_isUnset bishbosh_connect_cleanSession; then
        bishbosh_connect_cleanSession=1;
    fi;
    if [ $bishbosh_connect_cleanSession -eq 0 ]; then
        _bishbosh_connection_defaultFolderPath bishbosh_connection_sessionPath "$bishbosh_sessionPath"/servers/"$bishbosh_server"/ports/"$bishbosh_port"/client-ids "_${bishbosh_clientId}";
    else
        _bishbosh_connection_defaultFolderPath bishbosh_connection_sessionPath "$bishbosh_temporaryFolderPath" session;
        local formerCleanSession0Path="$bishbosh_sessionPath"/servers/"$bishbosh_server"/ports/"$bishbosh_port"/client-ids/"_${bishbosh_clientId}";
        if [ -d "$formerCleanSession0Path" ]; then
            bishbosh_connection_cleanContentsOfFolderPath "$formerCleanSession0Path";
        fi;
    fi;
    _bishbosh_connection_defaultFolderPath bishbosh_connection_sessionOurPacketIdentifiersPath "$bishbosh_connection_sessionPath" our-packet-identifiers;
    _bishbosh_connection_defaultFolderPath bishbosh_connection_sessionTheirPacketIdentifiersPath "$bishbosh_connection_sessionPath" their-packet-identifiers;
    _bishbosh_connection_defaultFolderPath bishbosh_connection_sessionRetransmissionPath "$bishbosh_connection_sessionPath" retransmission;
    bishbosh_connection_cleanContentsOfFolderPath "$bishbosh_connection_sessionRetransmissionPath";
    bishbosh_connection_packetIdentifier_transmissionCounter=0;
    bishbosh_connection_packetIdentifier_inFlight=0;
    bishbosh_connection_packetIdentifier_forWriting=1;
    local packetIdentifier;
    local transmissionCounterFile;
    local transmissionCounter;
    local paddedTransmissionCounter;
    local specificRetransmissionPath;
    pushd "$bishbosh_connection_sessionOurPacketIdentifiersPath";
    set +f;
    for packetIdentifier in *;
    do
        set -f;
        if [ ! -d "$packetIdentifier" ]; then
            if [ ! -e "$packetIdentifier" ]; then
                continue;
            fi;
            core_exitError $core_commandLine_exitCode_DATAERR "What is '$packetIdentifier' doing in sent stored session state at '$bishbosh_connection_sessionOurPacketIdentifiersPath'?";
        fi;
        transmissionCounterFile="$packetIdentifier"/transmission-counter;
        if [ ! -f "$transmissionCounterFile" ]; then
            core_message WARN "Cleaning up sent packet identifier '$packetIdentifier' that lacks a transmission-counter";
            rm -rf "$packetIdentifier";
            continue;
        fi;
        bishbosh_connection_packetIdentifier_inFlight=$((bishbosh_connection_packetIdentifier_inFlight+1));
        transmissionCounter="$(<"$transmissionCounterFile")";
        if [ $transmissionCounter -ge $bishbosh_connection_packetIdentifier_transmissionCounter ]; then
            bishbosh_connection_packetIdentifier_transmissionCounter=$((transmissionCounter+1));
        fi;
        paddedTransmissionCounter="$(printf '%09s' $transmissionCounter)";
        specificRetransmissionPath="$bishbosh_connection_sessionRetransmissionPath"/"$paddedTransmissionCounter";
        ln -s "$bishbosh_connection_sessionOurPacketIdentifiersPath"/"$packetIdentifier" "$specificRetransmissionPath" || core_exitError $core_commandLine_exitCode_DATAERR "Sent retransmission '$transmissionCounter' (padded as '$paddedTransmissionCounter') already exists for '$packetIdentifier' at path '$specificRetransmissionPath'.";
    done;
    set -f;
    popd;
    pushd "$bishbosh_connection_sessionTheirPacketIdentifiersPath";
    set +f;
    for packetIdentifier in *;
    do
        set -f;
        if [ ! -d "$packetIdentifier" ]; then
            if [ ! -e "$packetIdentifier" ]; then
                continue;
            fi;
            core_exitError $core_commandLine_exitCode_DATAERR "What is '$packetIdentifier' doing in received stored session state at '$bishbosh_connection_sessionOurPacketIdentifiersPath'?";
        fi;
        transmissionCounterFile="$packetIdentifier"/transmission-counter;
        if [ ! -f "$transmissionCounterFile" ]; then
            core_message WARN "Cleaning up sent packet identifier '$packetIdentifier' that lacks a transmission-counter";
            rm -rf "$packetIdentifier";
            continue;
        fi;
        transmissionCounter="$(<"$transmissionCounterFile")";
        if [ $transmissionCounter -ge $bishbosh_connection_packetIdentifier_transmissionCounter ]; then
            bishbosh_connection_packetIdentifier_transmissionCounter=$((transmissionCounter+1));
        fi;
        paddedTransmissionCounter="$(printf '%09s' $transmissionCounter)";
        specificRetransmissionPath="$bishbosh_connection_sessionRetransmissionPath"/"$paddedTransmissionCounter";
        ln -s "$bishbosh_connection_sessionTheirPacketIdentifiersPath"/"$packetIdentifier" "$specificRetransmissionPath" || core_exitError $core_commandLine_exitCode_DATAERR "Received retransmission '$transmissionCounter' (padded as '$paddedTransmissionCounter') already exists for '$packetIdentifier' at path '$specificRetransmissionPath'.";
    done;
    set -f;
    popd
}
bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath () 
{ 
    ourPacketIdentifierFolderPath="$bishbosh_connection_sessionOurPacketIdentifiersPath"/$packetIdentifier
}
bishbosh_connection_packetIdentifier_retireOneOfOurs () 
{ 
    bishbosh_connection_packetIdentifier_inFlight=$((bishbosh_connection_packetIdentifier_inFlight-1));
    ourPacketIdentifierFolderPath="$bishbosh_connection_sessionOurPacketIdentifiersPath"/"$packetIdentifier";
    rm -rf "$ourPacketIdentifierFolderPath"
}
bishbosh_connection_packetIdentifier_theirPacketIdentifierFolderPath () 
{ 
    theirPacketIdentifierFolderPath="$bishbosh_connection_sessionOurPacketIdentifiersPath"/$packetIdentifier
}
bishbosh_connection_packetIdentifier_useOneOfOurs () 
{ 
    local kind="$1";
    local callback="$2";
    shift 2;
    if [ $bishbosh_connection_packetIdentifier_inFlight -eq 65535 ]; then
        core_exitError $core_commandLine_exitCode_DATAERR "All packet identifiers are in flight";
    fi;
    bishbosh_connection_packetIdentifier_inFlight=$((bishbosh_connection_packetIdentifier_inFlight+1));
    while [ -d "$bishbosh_connection_sessionOurPacketIdentifiersPath"/$bishbosh_connection_packetIdentifier_forWriting ]; do
        if [ $bishbosh_connection_packetIdentifier_forWriting -eq 65535 ]; then
            bishbosh_connection_packetIdentifier_forWriting=1;
        else
            bishbosh_connection_packetIdentifier_forWriting=$((bishbosh_connection_packetIdentifier_forWriting+1));
        fi;
    done;
    ourPacketIdentifierFolderPath="$bishbosh_connection_sessionOurPacketIdentifiersPath"/"$bishbosh_connection_packetIdentifier_forWriting";
    mkdir -m 0700 -p "$ourPacketIdentifierFolderPath";
    printf '' > "$ourPacketIdentifierFolderPath"/"$kind";
    $callback "$@";
    bishbosh_connection_packetIdentifier_incrementTransmissionCounter "$ourPacketIdentifierFolderPath"
}
bishbosh_connection_packetIdentifier_write () 
{ 
    bishbosh_connection_write_twoByteLength $bishbosh_connection_packetIdentifier_forWriting
}
bishbosh_connection_ping_initialise () 
{ 
    bishbosh_connection_ping_responsePending=0;
    if core_variable_isUnset bishbosh_connect_keepAlive; then
        bishbosh_connect_keepAlive=0;
    fi;
    if [ $bishbosh_connect_keepAlive -ne 0 ]; then
        if [ $bishbosh_readLatency -ge 1000 ]; then
            if [ $bishbosh_connect_keepAlive -lt 2 ]; then
                core_message WARN "When the option '--read-latency' (or configuration setting 'bishbosh_readLatency') is 1000 ms, 'bishbosh_connect_keepAlive' must be at least 2 seconds (not '$bishbosh_connect_keepAlive'). bishbosh_connect_keepAlive is being forcing to 2 seconds.";
                bishbosh_connect_keepAlive=2;
            fi;
        fi;
        bishbosh_connection_ping_sendPingIfRequired () 
        { 
            if [ $bishbosh_connection_ping_responsePending -eq 1 ]; then
                return 0;
            fi;
            if bishbosh_connection_ping_checkTimer -lt $bishbosh_connect_keepAlive; then
                return 0;
            fi;
            core_message INFO 'Writing PINGREQ';
            bishbosh_connection_write_PINGREQ;
            bishbosh_connection_ping_responsePending=1
        };
        bishbosh_connection_ping_recordLastSentControlPacketAt () 
        { 
            if [ $bishbosh_connection_ping_responsePending -eq 1 ]; then
                return 0;
            fi;
            bishbosh_connection_ping_resetTimer
        };
        bishbosh_connection_ping_checkForResponseTimeout () 
        { 
            if [ $bishbosh_connection_ping_responsePending -eq 0 ]; then
                return 0;
            fi;
            if bishbosh_connection_ping_checkTimer -gt $bishbosh_pingTimeout; then
                bishbosh_connection_error_pingTimeout;
            fi
        };
        bishbosh_connection_ping_responseReceived () 
        { 
            core_message INFO 'Received valid PINGRESP';
            bishbosh_connection_ping_responsePending=0
        };
        if core_variable_isSet SECONDS; then
            bishbosh_connection_ping_resetTimer () 
            { 
                SECONDS=0
            };
            bishbosh_connection_ping_checkTimer () 
            { 
                [ $SECONDS $1 $2 ]
            };
            return 0;
        fi;
        if core_compatibility_whichNoOutput date; then
            _bishbosh_connection_ping_timer=0;
            bishbosh_connection_ping_resetTimer () 
            { 
                _bishbosh_connection_ping_timer=$(date '+%s')
            };
            bishbosh_connection_ping_checkTimer () 
            { 
                local now=$(date '+%s');
                local elapsedTime=$((now-_bishbosh_connection_ping_timer));
                [ $elapsedTime $1 $2 ]
            };
            return 0;
        fi;
        core_message WARN "Your shell does not support 'SECONDS' and the 'date' program isn't unavailble. Overriding your setting of 'bishbosh_connect_keepAlive as '$bishbosh_connect_keepAlive' to '0' (ie disabling).";
        bishbosh_connect_keepAlive=0;
    fi;
    bishbosh_connection_ping_sendPingIfRequired () 
    { 
        :
    };
    bishbosh_connection_ping_recordLastSentControlPacketAt () 
    { 
        :
    };
    bishbosh_connection_ping_checkForResponseTimeout () 
    { 
        :
    };
    bishbosh_connection_ping_responseReceived () 
    { 
        bishbosh_connection_error_protocolReadControlPacket PINGRESP 'Pings should not be received when Keep Alive is 0'
    };
    bishbosh_connection_write_PINGREQ () 
    { 
        bishbosh_connection_error_protocol "PINGREQ should not be called when Keep Alive is 0"
    }
}
bishbosh_connection_read_byte_initialise () 
{ 
    if [ $bishbosh_connection_supportsNonBlockingRead -eq 1 ]; then
        bishbosh_connection_read_byte_blocking () 
        { 
            set +e;
            IFS=' ' read -r -u 3 $1;
            set -e
        };
        bishbosh_connection_read_byte_nonBlocking () 
        { 
            set +e;
            IFS=' ' read -r -u 3 -t $bishbosh_readLatency_inFractionalSeconds $1;
            set -e
        };
        bishbosh_connection_read_byte_nonBlockingInitialise () 
        { 
            :
        };
    else
        bishbosh_connection_read_byte_blocking () 
        { 
            set +e;
            IFS=' ' read -r $1 0<&3;
            set -e
        };
        bishbosh_connection_read_byte_nonBlocking () 
        { 
            trap 'true' HUP;
            set +e;
            IFS=' ' read -r $1 0<&3 2> /dev/null;
            set -e;
            trap '' HUP
        };
        bishbosh_connection_read_byte_nonBlockingInitialise () 
        { 
            trap '' HUP
        };
    fi
}
bishbosh_connection_read_controlpacket_CONNACK () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot CONNACK 2;
    local connectAcknowledgeFlags;
    bishbosh_connection_read_byte_blocking connectAcknowledgeFlags;
    case $connectAcknowledgeFlags in 
        0)
            bishbosh_connection_sessionPresent=0
        ;;
        1)
            bishbosh_connection_sessionPresent=1
        ;;
        *)
            bishbosh_connection_error_protocolReadControlPacket CONNACK "Field 'connectAcknowledgeFlags' was '$connectAcknowledgeFlags', not a value between 0 to 1 inclusive"
        ;;
    esac;
    local connectReturnCode;
    bishbosh_connection_read_byte_blocking connectReturnCode;
    case $connectReturnCode in 
        0)
            :
        ;;
        1)
            bishbosh_connection_error_connectReturnCode $core_commandLine_exitCode_UNAVAILABLE 'Connection Refused, unacceptable protocol version'
        ;;
        2)
            bishbosh_connection_error_connectReturnCode $core_commandLine_exitCode_NOUSER 'Connection Refused, identifier rejected'
        ;;
        3)
            bishbosh_connection_error_connectReturnCode $core_commandLine_exitCode_UNAVAILABLE 'Connection Refused, Server unavailable'
        ;;
        4)
            bishbosh_connection_error_connectReturnCode $core_commandLine_exitCode_NOPERM 'Connection Refused, bad user name or password'
        ;;
        5)
            bishbosh_connection_error_connectReturnCode $core_commandLine_exitCode_NOPERM 'Connection Refused,  not authorized'
        ;;
        *)
            bishbosh_connection_error_protocolReadControlPacket CONNACK "Received reserved connectReturnCode code of $connectReturnCode"
        ;;
    esac;
    bishbosh_connection_handler_CONNACK;
    bishbosh_connection_read_controlpacket_CONNACK_retransmit
}
bishbosh_connection_read_controlpacket_CONNACK_retransmit () 
{ 
    pushd "$bishbosh_connection_sessionRetransmissionPath";
    local packetIdentifier;
    set +f;
    for paddedTransmissionIdentifier in *;
    do
        set -f;
        if [ ! -e "$paddedTransmissionIdentifier" ]; then
            continue;
        fi;
        pushd "$paddedTransmissionIdentifier";
        packetIdentifier="$(core_compatibility_basename "$(pwd -P)")";
        if [ -f 'message-sent' ]; then
            if [ -f 'pubrec-received' ]; then
                bishbosh_connection_write_rePUBREL;
            else
                bishbosh_connection_write_rePUBLISH;
            fi;
        else
            if [ -f 'message-received' ]; then
                bishbosh_connection_write_rePUBREC;
            else
                if [ -f 'subscribe' ]; then
                    bishbosh_connection_write_reSUBSCRIBE;
                else
                    if [ -f 'unsubscribe' ]; then
                        bishbosh_connection_write_reUNSUBSCRIBE;
                    else
                        core_message WARN "Can not retransmit packet identifier '$packetIdentifier' - unrecognised kind";
                    fi;
                fi;
            fi;
        fi;
        popd;
    done;
    set -f;
    popd
}
bishbosh_connection_read_controlpacket_PINGRESP () 
{ 
    bishbosh_connection_error_ifRemainingLengthNotZero PINGRESP;
    bishbosh_connection_ping_responseReceived;
    bishbosh_connection_handler_PINGRESP
}
bishbosh_connection_read_controlpacket_PUBACK () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot PUBACK 2;
    local packetIdentifier;
    bishbosh_connection_read_packetIdentifier;
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local unknownPacketIdentifier;
    if [ -f "$ourPacketIdentifierFolderPath"/publish ]; then
        unknownPacketIdentifier=0;
    else
        unknownPacketIdentifier=1;
        core_message WARN "Received a PUBACK with packet identifier '$packetIdentifier' for a PUBLISH that doesn't appear to be ours'";
    fi;
    bishbosh_connection_handler_PUBACK;
    bishbosh_connection_packetIdentifier_retireOneOfOurs
}
bishbosh_connection_read_controlpacket_PUBCOMP () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot PUBCOMP 2;
    local packetIdentifier;
    bishbosh_connection_read_packetIdentifier;
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local unknownPacketIdentifier;
    if [ -f "$ourPacketIdentifierFolderPath"/pubrec-received ]; then
        unknownPacketIdentifier=0;
    else
        unknownPacketIdentifier=1;
        core_message WARN "Received a PUBCOMP with packet identifier '$packetIdentifier' for a PUBREL that doesn't appear to be ours'";
    fi;
    bishbosh_connection_handler_PUBCOMP;
    bishbosh_connection_packetIdentifier_retireOneOfOurs
}
bishbosh_connection_read_controlpacket_PUBLISH_0 () 
{ 
    local retain=0;
    local QoS=0;
    local dup=0;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_1 () 
{ 
    local retain=1;
    local QoS=0;
    local dup=0;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_10 () 
{ 
    local retain=0;
    local QoS=1;
    local dup=1;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_11 () 
{ 
    local retain=1;
    local QoS=1;
    local dup=1;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_12 () 
{ 
    local retain=0;
    local QoS=2;
    local dup=1;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_13 () 
{ 
    local retain=1;
    local QoS=2;
    local dup=1;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_2 () 
{ 
    local retain=0;
    local QoS=1;
    local dup=0;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_3 () 
{ 
    local retain=1;
    local QoS=1;
    local dup=0;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_4 () 
{ 
    local retain=0;
    local QoS=2;
    local dup=0;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_5 () 
{ 
    local retain=1;
    local QoS=2;
    local dup=0;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBREC () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot PUBREC 2;
    local packetIdentifier;
    bishbosh_connection_read_packetIdentifier;
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local unknownPacketIdentifier;
    local duplicate;
    if [ -f "$ourPacketIdentifierFolderPath"/pubrec-received ]; then
        unknownPacketIdentifier=0;
        duplicate=1;
    else
        if [ -f "$ourPacketIdentifierFolderPath"/publish ]; then
            unknownPacketIdentifier=0;
            duplicate=0;
        else
            unknownPacketIdentifier=1;
            duplicate=0;
            core_message WARN "Received a PUBREC with packet identifier '$packetIdentifier' for a PUBLISH that doesn't appear to be ours'";
        fi;
    fi;
    bishbosh_connection_handler_PUBREC;
    printf '' > "$ourPacketIdentifierFolderPath"/pubrec-received;
    bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_write_PUBREL
}
bishbosh_connection_read_controlpacket_PUBREL () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot PUBREL 2;
    local packetIdentifier;
    bishbosh_connection_read_packetIdentifier;
    local theirPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_theirPacketIdentifierFolderPath;
    local unknownPacketIdentifier;
    if [ -f "$theirPacketIdentifierFolderPath"/transmission-counter ]; then
        unknownPacketIdentifier=0;
    else
        unknownPacketIdentifier=1;
    fi;
    bishbosh_connection_handler_PUBREL;
    bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_write_PUBCOMP;
    rm -rf "$theirPacketIdentifierFolderPath" 2> /dev/null
}
bishbosh_connection_read_controlpacket_SUBACK () 
{ 
    local packetIdentifier;
    bishbosh_connection_read_packetIdentifier;
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local unknownPacketIdentifier;
    if [ -f "$ourPacketIdentifierFolderPath"/subscribe ]; then
        unknownPacketIdentifier=0;
    else
        unknownPacketIdentifier=1;
        core_message WARN "Received a SUBACK with packet identifier '$packetIdentifier' for a SUBSCRIBE that doesn't appear to be ours'";
    fi;
    local returnCodeCount=$((remainingLength-2));
    if [ $returnCodeCount -eq 0 ]; then
        bishbosh_connection_error_protocolReadControlPacket SUBACK "Received no return codes";
    fi;
    local topicFiltersPath="$ourPacketIdentifierFolderPath"/topic-filters;
    if [ -d "$topicFiltersPath"/"$(printf '%09s' $returnCodeCount)" ]; then
        bishbosh_connection_error_protocolReadControlPacket SUBACK "Received too few return codes '$returnCodeCount'";
    fi;
    set --;
    local topicFiltersPath="$ourPacketIdentifierFolderPath"/topic-filters;
    local returnCode;
    local index=0;
    while [ $index -ne $returnCodeCount ]; do
        if [ ! -d "$topicFiltersPath"/"$(printf '%09s' $index)" ]; then
            bishbosh_connection_error_protocolReadControlPacket SUBACK "Received too many return codes '$returnCodeCount' (request '$index' does not exist)";
        fi;
        bishbosh_connection_read_byte_blocking returnCode;
        case $returnCode in 
            0 | 1 | 2 | 128)
                IFS=' ' set -- "$@" $returnCode
            ;;
            *)
                bishbosh_connection_error_protocolReadControlPacket SUBACK "Received reserved returnCode code of '$returnCode' in zero-based position '$index'"
            ;;
        esac;
        index=$((index+1));
    done;
    bishbosh_connection_handler_SUBACK "$@";
    bishbosh_connection_packetIdentifier_retireOneOfOurs
}
bishbosh_connection_read_controlpacket_UNSUBACK () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot UNSUBACK 2;
    local packetIdentifier;
    bishbosh_connection_read_packetIdentifier;
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local unknownPacketIdentifier;
    if [ -f "$ourPacketIdentifierFolderPath"/unsubscribe ]; then
        unknownPacketIdentifier=0;
    else
        unknownPacketIdentifier=1;
        core_message WARN "Received an UNSUBACK with packet identifier '$packetIdentifier' for an UNSUBSCRIBE that doesn't appear to be ours'";
    fi;
    bishbosh_connection_handler_UNSUBACK;
    bishbosh_connection_packetIdentifier_retireOneOfOurs
}
bishbosh_connection_read_controlpacket_handle () 
{ 
    case $controlPacketByte in 
        16)
            bishbosh_connection_read_controlpacket_CONNECT
        ;;
        32)
            bishbosh_connection_read_controlpacket_invalid
        ;;
        48)
            bishbosh_connection_read_controlpacket_PUBLISH_0
        ;;
        49)
            bishbosh_connection_read_controlpacket_PUBLISH_1
        ;;
        50)
            bishbosh_connection_read_controlpacket_PUBLISH_2
        ;;
        51)
            bishbosh_connection_read_controlpacket_PUBLISH_3
        ;;
        52)
            bishbosh_connection_read_controlpacket_PUBLISH_4
        ;;
        53)
            bishbosh_connection_read_controlpacket_PUBLISH_5
        ;;
        58)
            bishbosh_connection_read_controlpacket_PUBLISH_10
        ;;
        59)
            bishbosh_connection_read_controlpacket_PUBLISH_11
        ;;
        60)
            bishbosh_connection_read_controlpacket_PUBLISH_12
        ;;
        61)
            bishbosh_connection_read_controlpacket_PUBLISH_13
        ;;
        64)
            bishbosh_connection_read_controlpacket_PUBACK
        ;;
        80)
            bishbosh_connection_read_controlpacket_PUBREC
        ;;
        98)
            bishbosh_connection_read_controlpacket_PUBREL
        ;;
        112)
            bishbosh_connection_read_controlpacket_PUBCOMP
        ;;
        130)
            bishbosh_connection_read_controlpacket_SUBSCRIBE
        ;;
        144)
            bishbosh_connection_read_controlpacket_SUBACK
        ;;
        162)
            bishbosh_connection_read_controlpacket_UNSUBSCRIBE
        ;;
        176)
            bishbosh_connection_read_controlpacket_UNSUBACK
        ;;
        192)
            bishbosh_connection_read_controlpacket_PINGREQ
        ;;
        208)
            bishbosh_connection_read_controlpacket_PINGRESP
        ;;
        224)
            bishbosh_connection_read_controlpacket_DISCONNECT
        ;;
        *)
            bishbosh_connection_read_controlpacket_invalid
        ;;
    esac
}
bishbosh_connection_read_controlpacket_initialise () 
{ 
    local isServer="$1";
    if core_variable_isTrue "$isServer"; then
        bishbosh_connection_read_controlpacket_CONNACK () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_SUBACK () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_UNSUBACK () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_controlpacket_PINGRESP () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
    else
        bishbosh_connection_read_CONNECT () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_SUBSCRIBE () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_UNSUBSCRIBE () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_controlpacket_PINGREQ () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_controlpacket_DISCONNECT () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
    fi
}
bishbosh_connection_read_controlpacket_invalid () 
{ 
    bishbosh_connection_error_protocolRead "Invalid control packet code '$controlPacketByte' with remaining length '$remainingLength'"
}
bishbosh_connection_read_initialise () 
{ 
    local isServer="$1";
    bishbosh_connection_read_controlpacket_initialise "$isServer";
    bishbosh_connection_read_nonBlockingFeatureTest;
    bishbosh_connection_read_byte_initialise
}
bishbosh_connection_read_length () 
{ 
    local lengthMsb;
    local lengthLsb;
    bishbosh_connection_read_byte_blocking lengthMsb;
    bishbosh_connection_read_byte_blocking lengthLsb;
    length=$((lengthMsb * 256 + lengthLsb))
}
bishbosh_connection_read_nonBlockingFeatureTest () 
{ 
    case "$core_init_shellDetected" in 
        pdksh | mksh)
            bishbosh_connection_supportsNonBlockingRead=0;
            bishbosh_connection_exitCodeForReadTimeout=-1;
            return 0
        ;;
    esac;
    local testFifoPath="$(bishbosh_connection_mkfifo 'non-blocking-read-feature-test')";
    exec 3<> "$testFifoPath";
    local exitCode;
    set +e;
    printf '%s\n' 'test' 1>&3 2> /dev/null;
    exitCode=$?;
    set -e;
    if [ $exitCode -ne 0 ]; then
        core_message INFO "It seems there might be problems with FIFOs - we're assuming you're on Cygwin";
        bishbosh_connection_supportsNonBlockingRead=1;
        bishbosh_connection_exitCodeForReadTimeout=1;
        return 0;
    fi;
    local testVariable='';
    set +e;
    read -r -u 3 -t $bishbosh_readLatency_inFractionalSeconds testVariable 2> /dev/null;
    exitCode=$?;
    set -e;
    exec 3>&-;
    exec 3>&-;
    if [ -z "$testVariable" ]; then
        bishbosh_connection_supportsNonBlockingRead=0;
        bishbosh_connection_exitCodeForReadTimeout=-1;
        return 0;
    else
        bishbosh_connection_supportsNonBlockingRead=1;
    fi;
    local timeoutExitCodeFifoPath="$(bishbosh_connection_mkfifo 'non-blocking-read-timeout-exit-code-feature-test')";
    exec 3<> "$testFifoPath";
    set +e;
    read -r -u 3 -t $bishbosh_readLatency_inFractionalSeconds testVariable;
    bishbosh_connection_exitCodeForReadTimeout=$?;
    exec 3>&-;
    exec 3>&-;
    set -e
}
bishbosh_connection_read_packetIdentifier () 
{ 
    local packetIdentifierMsb;
    local packetIdentifierLsb;
    bishbosh_connection_read_byte_blocking packetIdentifierMsb;
    bishbosh_connection_read_byte_blocking packetIdentifierLsb;
    packetIdentifier=$((packetIdentifierMsb * 256 + packetIdentifierLsb))
}
bishbosh_connection_read_remainingLength () 
{ 
    local controlPacket="$1";
    local remainingLengthByte;
    bishbosh_connection_read_byte_blocking remainingLengthByte;
    if [ $remainingLengthByte -lt 128 ]; then
        remainingLength=$remainingLengthByte;
        return 0;
    fi;
    remainingLength=$((remainingLengthByte-128));
    bishbosh_connection_read_byte_blocking remainingLengthByte;
    if [ $remainingLengthByte -lt 128 ]; then
        remainingLength=$((remainingLength+remainingLengthByte*128));
        return 0;
    fi;
    remainingLength=$((remainingLength+(remainingLengthByte-128)*128));
    bishbosh_connection_read_byte_blocking remainingLengthByte;
    if [ $remainingLengthByte -lt 128 ]; then
        remainingLength=$((remainingLength+remainingLengthByte*128*128));
        return 0;
    fi;
    remainingLength=$((remainingLength+(remainingLengthByte-128)*128*128));
    bishbosh_connection_read_byte_blocking remainingLengthByte;
    if [ $remainingLengthByte -lt 128 ]; then
        remainingLength=$((remainingLength+remainingLengthByte*128*128*128));
        return 0;
    fi;
    bishbosh_connection_error_protocolReadControlPacket "$controlPacket" "Remaining length exceeds four bytes"
}
bishbosh_connection_sourceScriptlets () 
{ 
    local path="$1";
    mkdir -m 0755 -p "$path" 2> /dev/null;
    local scriptletFilePath="$path"/rc;
    if core_path_isReadableNonEmptyFilePath "$scriptletFilePath"; then
        . "$scriptletFilePath";
    fi;
    local scriptletsFolderPath="$path"/rc.d;
    if [ ! -d "$scriptletsFolderPath" ]; then
        return 0;
    fi;
    pushd "$scriptletsFolderPath";
    set +f;
    for scriptletFilePath in *;
    do
        set -f;
        if ! core_path_isReadableNonEmptyFilePath "$scriptletFilePath"; then
            if [ "$scriptletFilePath" = '*' ]; then
                continue;
            fi;
            core_exitError "The client-id scriptlet file '$scriptletFilePath' is not a readable, non-empty file";
        fi;
        . ./"$scriptletFilePath";
    done;
    set -f;
    popd
}
bishbosh_connection_validate_clientId () 
{ 
    bishbosh_connection_validate_isUtf8 bishbosh_clientId "$bishbosh_clientId";
    if [ ${#bishbosh_clientId} -gt 254 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The option -i,--client-id or configuration setting bishbosh_clientId '$bishbosh_clientId' is longer than 254 bytes. ${_program_name} can not support this.";
    fi;
    if [ ${#bishbosh_clientId} -gt 23 ]; then
        core_message WARN "Not all MQTT servers support a ClientId of more than 23 encoded bytes.";
    fi;
    _bishbosh_connection_validate_clientId_restrictedCharacters
}
bishbosh_connection_validate_fieldLength () 
{ 
    local packetName="$1";
    local variableName="$2";
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    if [ ${#core_variable_indirectValue_result} -gt 65535 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connection_write_${packetName}_${variableName}' can not be longer than 65,535 bytes";
    fi
}
bishbosh_connection_validate_initialise () 
{ 
    if core_compatibility_whichNoOutput iconv; then
        _bishbosh_connection_validate_isUtf8_iconv_iconv () 
        { 
            iconv -c -s -f utf-8 -t utf-8 > /dev/null  <<-EOF
$value
EOF

        }
        _bishbosh_connection_validate_isUtf8_iconv () 
        { 
            if ! _bishbosh_connection_validate_isUtf8_iconv_iconv; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' is not valid UTF-8";
            fi
        };
    else
        core_message WARN "Disabling UTF-8 validation because 'iconv' isn't available";
        _bishbosh_connection_validate_isUtf8_iconv () 
        { 
            :
        };
    fi;
    if core_compatibility_whichNoOutput sed; then
        _bishbosh_connection_validate_topicFilter_sed_sed () 
        { 
            sed -e 's;/+/;XXX;g' -e 's;^+/;XX;g' -e 's;/+$;XX;g' -e 's;/#$;XX;g' -e 's;#;;g' -e 's;+;;g'  <<-EOF
$value
EOF

        }
        _bishbosh_connection_validate_topicFilter_sed () 
        { 
            local strippedOfWildcard="$(_bishbosh_connection_validate_topicFilter_sed_sed)";
            if [ ${#strippedOfWildcard} -ne ${#topicFilter} ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' ('$value') contains invalid wildcards";
            fi
        };
    else
        core_message WARN "Disabling some topic filter validation because 'sed' isn't available";
        _bishbosh_connection_validate_topicFilter_sed () 
        { 
            :
        };
    fi;
    if core_compatibility_whichNoOutput tr; then
        bishbosh_connection_validate_removeCharacters () 
        { 
            local strip="$1";
            local value="$2";
            printf '%s' "$value" | tr -d "$strip"
        };
        _bishbosh_connection_validate_clientId_restrictedCharacters () 
        { 
            local stripped="$(printf '%s' "$bishbosh_clientId" | tr -d -c '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')";
            if [ ${#stripped} -ne ${#bishbosh_clientId} ]; then
                core_message WARN "Not all MQTT servers support a ClientId with characters other than 0-9, a-z and A-Z.";
            fi
        };
    else
        core_message WARN "Disabling invalid character validation because 'tr' isn't available";
        bishbosh_connection_validate_removeCharacters () 
        { 
            local strip="$1";
            local value="$2";
            printf '%s' "$value"
        };
        core_message WARN "Disabling Client Id restricted character validation because 'tr' isn't available";
        _bishbosh_connection_validate_clientId_restrictedCharacters () 
        { 
            :
        };
    fi;
    if core_variable_isSet ZSH_VERSION; then
        _bishbosh_connection_validate_isUtf8_asciiNul () 
        { 
            local strippedOfAsciiNul="$(bishbosh_connection_validate_removeCharacters '\000' "$value")";
            if [ ${#strippedOfAsciiNul} -ne ${#value} ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' contains U+0000 (NUL)";
            fi
        };
    else
        _bishbosh_connection_validate_isUtf8_asciiNul () 
        { 
            :
        };
    fi
}
bishbosh_connection_validate_isUtf8 () 
{ 
    local argument="$1";
    local value="$2";
    _bishbosh_connection_validate_isUtf8_iconv;
    _bishbosh_connection_validate_isUtf8_asciiNul
}
bishbosh_connection_validate_packetIdentifier () 
{ 
    core_validate_isUnsignedInteger $core_commandLine_exitCode_CONFIG 'argument' "bishbosh_connection_packetIdentifier_forWriting" "$bishbosh_connection_packetIdentifier_forWriting";
    if [ $bishbosh_connection_packetIdentifier_forWriting -eq 0 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connection_packetIdentifier_forWriting' is a packet identifier and so can not be 0";
    fi;
    if [ $bishbosh_connection_packetIdentifier_forWriting -gt 65535 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connection_packetIdentifier_forWriting' is a packet identifier and so can not be greater than 65,535";
    fi
}
bishbosh_connection_validate_publishMessageFieldLength () 
{ 
    local maximumLength=$((268435455-2-topicNameFieldLength));
    if [ $QoS -ne 0 ]; then
        maximumLength=$((maximumLength-2));
    fi;
    if [ $messageFieldLength -gt $maximumLength ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The message can not be longer than $maximumLength bytes when topicName is $topicNameFieldLength bytes and QoS is $QoS.";
    fi
}
bishbosh_connection_validate_topicFilter () 
{ 
    local argument="$1";
    local index=$2;
    local value=$3;
    argument="$argument' at pair index '$index";
    if [ ${#value} -eq 0 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' is empty; this is not permitted for topic filters";
    fi;
    _bishbosh_connection_validate_isUtf8_iconv;
    local strippedTopicFilter="$(bishbosh_connection_validate_removeCharacters '\n\000' "$value")";
    if [ ${#strippedTopicFilter} -ne ${#value} ]; then
        _bishbosh_connection_validate_isUtf8_asciiNul;
        core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' has a topic filter containing \n (LF, Linefeed), which, although allowed in the MQTT 3.1.1 specification can not be supported in portable shell scripts or common tools (outside of those supplied by GNU)";
    fi;
    _bishbosh_connection_validate_topicFilter_sed
}
bishbosh_connection_validate_topicName () 
{ 
    local argument="$1";
    local value="$2";
    if [ ${#value} -eq 0 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' is empty; this is not permitted for topic names";
    fi;
    _bishbosh_connection_validate_isUtf8_iconv;
    local strippedOfInvalidCharacters="$(bishbosh_connection_validate_removeCharacters '#*\000' "$value")";
    if [ ${#strippedOfInvalidCharacters} -ne ${#value} ]; then
        _bishbosh_connection_validate_isUtf8_asciiNul;
        core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' ('$value') contains a wildcard ('#' or '+')";
    fi
}
bishbosh_connection_write_CONNECT () 
{ 
    local remainingLength=10;
    local connectFlags=0;
    local cleanSession;
    local willTopic;
    local willTopicFieldLength;
    local willMessage;
    local willMessageFilePath;
    local willMessageFieldLength;
    local willQoS;
    local keepAlive;
    local clientId;
    local clientIdFieldLength;
    local username;
    local usernameFieldLength;
    local password;
    local passwordFilePath;
    local passwordFieldLength;
    _bishbosh_connection_write_CONNECT_validateArguments;
    printf '\020';
    bishbosh_connection_write_remainingLength $remainingLength;
    printf '\000\004MQTT\004';
    bishbosh_connection_write_byte $connectFlags;
    bishbosh_connection_write_twoByteLength $keepAlive;
    bishbosh_connection_write_twoByteLength $clientIdFieldLength;
    printf '%s' "$clientId";
    if [ $willTopicFieldLength -ne -1 ]; then
        bishbosh_connection_write_twoByteLength $willTopicFieldLength;
        printf '%s' "$willTopic";
        bishbosh_connection_write_twoByteLength $willMessageFieldLength;
        if [ -z "$willMessageFilePath" ]; then
            printf '%s' "$willMessage";
        else
            bishbosh_connection_write_file "$willMessageFilePath" $willMessageFieldLength;
        fi;
    fi;
    if [ $usernameFieldLength -ne -1 ]; then
        bishbosh_connection_write_twoByteLength $usernameFieldLength;
        printf '%s' "$username";
    fi;
    if [ $passwordFieldLength -ne -1 ]; then
        bishbosh_connection_write_twoByteLength $passwordFieldLength;
        if [ -z "$passwordFilePath" ]; then
            printf '%s' "$password";
        else
            bishbosh_connection_write_file "$passwordFilePath" $passwordFieldLength;
        fi;
    fi;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_DISCONNECT () 
{ 
    printf '\340\000'
}
bishbosh_connection_write_PINGREQ () 
{ 
    printf '\300\000';
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_PUBACK () 
{ 
    bishbosh_connection_validate_packetIdentifier;
    printf '\100\002';
    bishbosh_connection_packetIdentifier_write;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_PUBCOMP () 
{ 
    bishbosh_connection_validate_packetIdentifier;
    printf '\160\002';
    bishbosh_connection_packetIdentifier_write;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_PUBREC () 
{ 
    bishbosh_connection_validate_packetIdentifier;
    printf '\120\002';
    bishbosh_connection_packetIdentifier_write;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_PUBREL () 
{ 
    bishbosh_connection_validate_packetIdentifier;
    printf '\142\002';
    bishbosh_connection_packetIdentifier_write;
    printf '' > "$ourPacketIdentifierFolderPath"/pubrel;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_byte () 
{ 
    printf "\\$(printf '%o' $1)"
}
bishbosh_connection_write_initialise () 
{ 
    if core_compatibility_whichNoOutput dd; then
        bishbosh_connection_write_file () 
        { 
            dd if="$1" bs=$2 count=1
        };
    else
        if core_compatibility_whichNoOutput cat; then
            bishbosh_connection_write_file () 
            { 
                cat "$1"
            };
        else
            if core_compatibility_whichNoOutput tee; then
                bishbosh_connection_write_file () 
                { 
                    tee < "$1"
                };
            else
                if core_compatibility_whichNoOutput tail; then
                    bishbosh_connection_write_file () 
                    { 
                        tail -c +0 "$1"
                    };
                else
                    if core_compatibility_whichNoOutput head; then
                        bishbosh_connection_write_file () 
                        { 
                            head -c "$1"
                        };
                    else
                        if core_compatibility_whichNoOutput tr; then
                            bishbosh_connection_write_file () 
                            { 
                                tr -d '' < "$1"
                            };
                        else
                            core_message WARN "Can not write message and password files, because dd, cat, tee, head and tr are missing";
                            bishbosh_connection_write_file () 
                            { 
                                core_exitError $core_commandLine_exitCode_OSFILE "Can not send files as messages or passwords, because dd, cat, tee, head and tr are missing"
                            };
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi
}
bishbosh_connection_write_rePUBLISH () 
{ 
    core_message INFO "re-PUBLISH-ing packet identifier '$packetIdentifier'";
    local controlPacketTypeAndFlags=48;
    local remainingLength=0;
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    _bishbosh_connection_write_rePUBLISH_setRetainFlag;
    local topicName;
    local topicNameFieldLength;
    _bishbosh_connection_write_rePUBLISH_setTopicName;
    local message;
    local messageFieldLength;
    local messageFilePath;
    local messageUnlinkFile;
    _bishbosh_connection_write_rePUBLISH_setMessage;
    _bishbosh_connection_write_PUBLISH_setQoS;
    _bishbosh_connection_write_PUBLISH_writeCommon;
    local bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_packetIdentifier_write;
    _bishbosh_connection_write_PUBLISH_writeMessagePingAndUnlink
}
bishbosh_connection_write_rePUBREC () 
{ 
    core_message INFO "re-PUBREC-ing packet identifier '$packetIdentifier'";
    printf '\120\002';
    bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_packetIdentifier_write;
    unbishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_rePUBREL () 
{ 
    core_message INFO "re-PUBREL-ing packet identifier '$packetIdentifier'";
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_write_PUBREL
}
bishbosh_connection_write_reSUBSCRIBE () 
{ 
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local topicFiltersPath="$ourPacketIdentifierFolderPath"/topic-filters;
    if [ ! -d "$topicFiltersPath" ]; then
        core_message WARN "There are no topic filters in '$topicFiltersPath'; data is corrupt";
        return 0;
    fi;
    local remainingLength=2;
    local paddedIndex;
    local topicFilterFieldLength;
    pushd "$topicFiltersPath";
    set +f;
    for paddedIndex in *;
    do
        set -f;
        if [ ! -e "$paddedIndex" ]; then
            core_message WARN "There are no padded indices in '$topicFiltersPath'; data is corrupt";
            return 0;
        fi;
        if [ ! -d "$paddedIndex" ]; then
            core_message WARN "What is '$topicFiltersPath'/'$paddedIndex' doing there?";
            continue;
        fi;
        topicFilterFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$paddedIndex"/topic-filter);
        remainingLength=$(( remainingLength + 3 + topicFilterFieldLength ));
    done;
    set -f;
    popd;
    printf '\202';
    bishbosh_connection_write_remainingLength $remainingLength;
    local bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_packetIdentifier_write;
    pushd "$topicFiltersPath";
    set +f;
    for paddedIndex in *;
    do
        set -f;
        topicFilterFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$paddedIndex"/topic-filter);
        bishbosh_connection_write_file "$paddedIndex"/topic-filter $topicFilterFieldLength;
        bishbosh_connection_write_byte $(<"$paddedIndex"/topic-qos);
    done;
    set -f;
    popd;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_reUNSUBSCRIBE () 
{ 
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local topicFiltersPath="$ourPacketIdentifierFolderPath"/topic-filters;
    if [ ! -d "$topicFiltersPath" ]; then
        core_message WARN "There are no topic filters in '$topicFiltersPath'; data is corrupt";
        return 0;
    fi;
    local remainingLength=2;
    local paddedIndex;
    local topicFilterFieldLength;
    pushd "$topicFiltersPath";
    set +f;
    for paddedIndex in *;
    do
        set -f;
        if [ ! -e "$paddedIndex" ]; then
            core_message WARN "There are no padded indices in '$topicFiltersPath'; data is corrupt";
            return 0;
        fi;
        if [ ! -d "$paddedIndex" ]; then
            core_message WARN "What is '$topicFiltersPath'/'$paddedIndex' doing there?";
            continue;
        fi;
        topicFilterFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$paddedIndex"/topic-filter);
        remainingLength=$(( remainingLength + 2 + topicFilterFieldLength ));
    done;
    set -f;
    popd;
    printf '\242';
    bishbosh_connection_write_remainingLength $remainingLength;
    local bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_packetIdentifier_write;
    pushd "$topicFiltersPath";
    set +f;
    for paddedIndex in *;
    do
        set -f;
        topicFilterFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$paddedIndex"/topic-filter);
        bishbosh_connection_write_file "$paddedIndex"/topic-filter $topicFilterFieldLength;
    done;
    set -f;
    popd;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_remainingLength () 
{ 
    if [ $1 -lt 128 ]; then
        bishbosh_connection_write_byte $1;
    else
        if [ $1 -lt 16384 ]; then
            local length=$1;
            bishbosh_connection_write_byte $(( length % 128 + 128 ));
            bishbosh_connection_write_byte $(( length / 128));
        else
            if [ $1 -lt 2097152 ]; then
                local length=$1;
                bishbosh_connection_write_byte $(( (length & 127) + 128 ));
                bishbosh_connection_write_byte $(( (length >> 7 & 127) + 128 ));
                bishbosh_connection_write_byte $((  length >> 14 & 127 ));
            else
                local length=$1;
                bishbosh_connection_write_byte $(( (length & 127) + 128 ));
                bishbosh_connection_write_byte $(( (length >> 7 & 127) + 128 ));
                bishbosh_connection_write_byte $(( (length >> 14 & 127) + 128 ));
                bishbosh_connection_write_byte $((  length >> 21 & 127 ));
            fi;
        fi;
    fi
}
bishbosh_connection_write_twoByteLength () 
{ 
    local length=$1;
    bishbosh_connection_write_byte $(( length >> 8 ));
    bishbosh_connection_write_byte $(( length & 255 ))
}
bishbosh_filesize_BSDStat () 
{ 
    stat -L -f '%z' "$1"
}
bishbosh_filesize_GNUAndBusyBoxStat () 
{ 
    stat -L -c '%s' "$1"
}
bishbosh_filesize_ToyboxStat () 
{ 
    stat -c '%s' "$1"
}
bishbosh_filesize_ls () 
{ 
    local permissions links uid gid size dateBitsAndFileName;
    IFS=' ' read -r  <<-EOF
$(ls -L -l -n "$1")
EOF

}
bishbosh_publishFile () 
{ 
    local bishbosh_publish_messageFilePath="$4";
    local bishbosh_publish_messageUnlinkFile=no;
    _bishbosh_publish "$1" "$2" "$3"
}
bishbosh_publishFileAndRemove () 
{ 
    local bishbosh_publish_messageFilePath="$4";
    local bishbosh_publish_messageUnlinkFile=yes;
    _bishbosh_publish "$1" "$2" "$3"
}
bishbosh_publishText () 
{ 
    if [ $# -eq 3 ]; then
        local bishbosh_publish_message='';
    else
        local bishbosh_publish_message="$4";
    fi;
    _bishbosh_publish "$1" "$2" "$3"
}
bishbosh_subscribe () 
{ 
    _bishbosh_connection_write_SUBSCRIBE "$@"
}
bishbosh_unsubscribe () 
{ 
    _bishbosh_connection_write_UNSUBSCRIBE "$@"
}
bishbosh_validate_address () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4"
}
bishbosh_validate_backends () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    if [ ${#value} -eq 0 ]; then
        core_validate_exit "The $category '$name' must specify at least one backend. Valid backends are '$(core_variable_array_string _bishbosh_backend_registration ',')'.";
    fi;
    local IFS=',';
    local backend;
    for backend in $value;
    do
        if ! core_variable_array_contains _bishbosh_backend_registration "$backend"; then
            core_validate_exit "The $category '$name' specifies a backend '$backend' which is not known. Valid backends are '$(core_variable_array_string _bishbosh_backend_registration ',')'.";
            return 0;
        fi;
    done
}
bishbosh_validate_filesizeAlgorithm () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    case "$value" in 
        ls)
            :
        ;;
        GNUAndBusyBoxStat)
            :
        ;;
        BSDStat)
            :
        ;;
        ToyboxStat)
            :
        ;;
        *)
            core_validate_exit "The $category '$name' specifies a filesize algorithm '$value' which is not understood (valid values are 'ls', 'GNUAndBusyBoxStat', 'BSDStat', and 'ToyboxStat')."
        ;;
    esac
}
bishbosh_validate_latency () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    core_validate_isUnsignedInteger $code "$category" "$name" "$value";
    if [ $value -gt 1000 ]; then
        core_validate_exit "The $category '$name' must be between 0 and 1000 (inclusive).";
    fi
}
bishbosh_validate_proxyIsOff () 
{ 
    if core_variable_isSet bishbosh_validate_proxyKind; then
        if [ "$core_variable_isSet" = "off" ]; then
            return 1;
        fi;
    fi;
    return 0
}
bishbosh_validate_proxyKind () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    case "$value" in 
        SOCKS4 | SOCKS4a | SOCKS5 | HTTP)
            :
        ;;
        none)
            :
        ;;
        *)
            core_validate_exit "The $category '$name' specifies a proxy kind '$value' which is not understood (valid values are 'SOCKS4', 'SOCKS5', 'HTTP' and 'none')."
        ;;
    esac
}
bishbosh_validate_transport () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    case "$value" in 
        inet)
            :
        ;;
        inet4)
            :
        ;;
        inet6)
            :
        ;;
        unix)
            :
        ;;
        serial)
            :
        ;;
        *)
            core_validate_exit "The $category '$name' specifies a transport '$value' which is not understood (valid values are 'inet' for OS-preferred v4/v6 connections, 'inet4', for IPv4-only connections, 'inet6', for IPv6-only connections,  'unix', for an Unix domain socket, and 'serial' for a character device)."
        ;;
    esac
}
bishbosh_validate_tunnel () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    case "$value" in 
        none)
            :
        ;;
        tls)
            :
        ;;
        cryptcat)
            :
        ;;
    esac
}
bishbosh_validate_unsignedIntegerUpto65535Inclusive () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    core_validate_isUnsignedInteger $code "$category" "$name" "$value";
    if [ $value -gt 65535 ]; then
        core_exitError $code "The $category '$name' specifies a value '$value' which is not between 0 and 65,535 inclusive.";
    fi
}
command_not_found_handle () 
{ 
    local programNotFound="$1";
    shift 1;
    core_exitError $core_commandLine_exitCode_OSFILE "Essential dependency '$programNotFound' not found on the PATH (with arguments $@)"
}
core_TODO () 
{ 
    core_message TODO "$*"
}
core_base64_decode_file () 
{ 
    local encodedFilePath="$1";
    local decodedFilePath="$2";
    local append="$3";
    local index62Character="$4";
    local index63Character="$5";
    if core_compatibility_whichNoOutput openssl; then
        if core_variable_isTrue "$append"; then
            openssl enc -base64 -d -in "$encodedFilePath" >> "$decodedFilePath";
        else
            openssl enc -base64 -d -in "$encodedFilePath" > "$decodedFilePath";
        fi;
        return 0;
    fi;
    if core_compatibility_whichNoOutput gbase64; then
        if core_variable_isTrue "$append"; then
            gbase64 -d "$encodedFilePath" >> "$decodedFilePath";
        else
            gbase64 -d "$encodedFilePath" > "$decodedFilePath";
        fi;
        return 0;
    fi;
    if core_compatibility_whichNoOutput base64; then
        local exitCode;
        if core_variable_isTrue "$append"; then
            set +e;
            base64 -D "$encodedFilePath" >> "$decodedFilePath" 2> /dev/null;
            exitCode=$?;
            set -e;
        else
            set +e;
            base64 -D "$encodedFilePath" > "$decodedFilePath" 2> /dev/null;
            exitCode=$?;
            set -e;
        fi;
        if [ $exitCode -eq 0 ]; then
            return 0;
        fi;
        if core_variable_isTrue "$append"; then
            set +e;
            base64 -d "$encodedFilePath" >> "$decodedFilePath" 2> /dev/null;
            exitCode=$?;
            set -e;
        else
            set +e;
            base64 -d "$encodedFilePath" > "$decodedFilePath" 2> /dev/null;
            exitCode=$?;
            set -e;
        fi;
        if [ $exitCode -eq 0 ]; then
            return 0;
        fi;
        core_message WARN "We don't recognise your 'base64' binary (or data is corrupt); use fallbacks";
    fi;
    if core_compatibility_whichNoOutput fold; then
        if core_variable_isTrue "$append"; then
            _core_base64_decode_file "$@" _core_base64_decode_file_fold >> "$decodedFilePath";
        else
            _core_base64_decode_file "$@" _core_base64_decode_file_fold > "$decodedFilePath";
        fi;
        return 0;
    fi;
    if core_compatibility_whichNoOutput awk; then
        if core_variable_isTrue "$append"; then
            _core_base64_decode_file "$@" _core_base64_decode_file_awk >> "$decodedFilePath";
        else
            _core_base64_decode_file "$@" _core_base64_decode_file_awk > "$decodedFilePath";
        fi;
        return 0;
    fi;
    core_exitError $core_commandLine_exitCode_OSFILE "No utility to decode base64 found (openssl, gbase64, base64, fold, awk)"
}
core_base64_decode_string () 
{ 
    local string="$1";
    local decodedFilePath="$2";
    local append="$3";
    local index62Character="$4";
    local index63Character="$5";
    shift 5;
    local TMP_FILE;
    core_temporaryFiles_newFileToRemoveOnExit;
    printf '%s' "$string" > "$TMP_FILE";
    core_base64_decode_file "$TMP_FILE" "$decodedFilePath" "$append" "$index62Character" "$index63Character";
    rm -f "$TMP_FILE" || true
}
core_children_initialise () 
{ 
    core_trap_addOnCleanUp core_children_killAll
}
core_children_killAll () 
{ 
    if core_variable_array_isSet _core_children_childrenToRemoveOnExit; then
        core_variable_array_passToFunctionAsArguments _core_children_childrenToRemoveOnExit _core_children_killAll_callback;
    fi
}
core_children_killOnExit () 
{ 
    local childPid;
    for childPid in "$@";
    do
        core_variable_array_append _core_children_childrenToRemoveOnExit "$childPid";
    done
}
core_commandLine_defaultLicenseMessage () 
{ 
    printf '%s' "LICENSE terms are documented in the COPYRIGHT file at the top-level directory of this distribution."
}
core_commandLine_exitBadCommandLine () 
{ 
    core_commandLine_helpMessage 1>&2;
    core_message FAIL "$1";
    exit $core_commandLine_exitCode_USAGE
}
core_commandLine_exitHelp () 
{ 
    core_commandLine_helpMessage 1>&2;
    exit $core_commandLine_exitCode_OK
}
core_commandLine_exitVersion () 
{ 
    core_commandLine_versionMessage 1>&2;
    exit $core_commandLine_exitCode_OK
}
core_commandLine_helpMessage () 
{ 
    _program_commandLine_helpMessage_usage="[OPTION]...";
    _program_commandLine_helpMessage_description="Does nothing.";
    _program_commandLine_helpMessage_options="";
    _program_commandLine_helpMessage_optionsSpacing='     ';
    _program_commandLine_helpMessage_configurationKeys="";
    _program_commandLine_helpMessage_examples="";
    _program_commandLine_helpMessage;
    printf '%s' Usage: "${_program_name} ${_program_commandLine_helpMessage_usage}
${_program_commandLine_helpMessage_description}

  -h, --help             ${_program_commandLine_helpMessage_optionsSpacing}display this help and exit
  -v, --verbose [LEVEL]  ${_program_commandLine_helpMessage_optionsSpacing}specify more than once to increase verbosity or
                         ${_program_commandLine_helpMessage_optionsSpacing}optionally set LEVEL to 0 - 2. Defaults to 0.
  -q, --quiet            ${_program_commandLine_helpMessage_optionsSpacing}specify to reduce verbosity
      --version          ${_program_commandLine_helpMessage_optionsSpacing}output version information and exit${_program_commandLine_helpMessage_options}
      --                 ${_program_commandLine_helpMessage_optionsSpacing}end of options

Notes
Long options with values may also be specified with '=', eg --verbose=2 as well
as --verbose 2. Separate options from operands (non-options) by using '--'.
This prevents interpretation of non-options as options. Concatenating short
options with arguments (eg -v2) is not supported.

Configuration
This program can be configured by creating files in the form 'key=value' in the
files and folders:-
  
  ${_program_etcPath}/${_program_name}/rc
  ${_program_etcPath}/${_program_name}/rc.d
  HOME/.${_program_name}/rc
  HOME/.${_program_name}/rc.d
  ${_program_namespace}_RC
  ${_program_namespace}_RC_D

Locations ending '.d' are folders which are searched for files. All files in a
folder are used in shell glob-expansion order. HOME, ${_program_namespace}_RC and
${_program_namespace}_RC_D are environment variables. If the variable
does not exist, or is blacklisted, the location is ignored.
Blacklisting is done by specifying:-

  core_configuration_blacklist  VARIABLE_NAME
  
in a configuration file. This allows the system administrator to prevent
overridding.

Files are used in the order above. If a file does not exist, it is ignored.
Those under a 'etc' folder must have the following permissions set:-

  * They are owned by root.
  * They are not group writable.
  * They are not world writable.
  * They do not reside in a group writable directory.
  * They do not reside in a world writable directory.
  * They are not a symbolic link to a file residing in a group or world
    writable directory. 

If the permissions are not set, the file is ignored.

Configuration Keys
  
  ${_program_namespace}_verbose   $(core_init_verbosity)  Controls message logging on stderr
  ${_program_namespace}_language  $(core_init_language)  Controls sort language${_program_commandLine_helpMessage_configurationKeys}
Values should be single or double-quoted if they contain whitespace.

Examples
${_program_commandLine_helpMessage_examples}
Path Files
A path file is used to define the location of essential programs used during
initial bootstrapping. It also defines a packageManager to automatically
install any missing dependencies.
"
}
core_commandLine_optionExists () 
{ 
    local optionName="$1";
    case "$optionName" in 
        h | help)
            echo yes-argumentless
        ;;
        v | verbose)
            echo yes-optionally-argumented
        ;;
        q | quiet)
            echo yes-argumentless
        ;;
        version)
            echo yes-argumentless
        ;;
        *)
            _program_commandLine_optionExists
        ;;
    esac
}
core_commandLine_parse () 
{ 
    _program_commandLine_parseInitialise;
    local argument;
    local parsingOptionArguments=0;
    while [ $# -ne 0 ]; do
        local argument="$1";
        if core_variable_startsWith "$argument" '--'; then
            shift 1;
            if [ "$argument" = '--' ]; then
                break;
            fi;
            case "$argument" in 
                --*=*)
                    local optionNameIncludingHyphens="${argument%%=*}";
                    local optionName="${optionNameIncludingHyphens##--}";
                    local optionValue="${argument#*=}";
                    case "$(core_commandLine_optionExists "$optionName")" in 
                        yes-argumentless)
                            core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' does not take values (such as '$optionValue')"
                        ;;
                        yes-argumented | yes-optionally-argumented)
                            core_commandLine_processOptionWithArgument
                        ;;
                        no | '')
                            core_commandLine_exitBadCommandLine "The long option (with =value) '${optionNameIncludingHyphens}' does not exist"
                        ;;
                        *)
                            core_exitError $core_commandLine_exitCode_SOFTWARE "Please implement yes-argumented, yes-argumentless, yes-optionally-argumented or no for option '$optionName' in _program_commandLine_optionExists()"
                        ;;
                    esac
                ;;
                --*)
                    local optionNameIncludingHyphens="$argument";
                    local optionName="${argument##--}";
                    case "$(core_commandLine_optionExists "$optionName")" in 
                        yes-argumentless)
                            core_commandLine_processOptionWithoutArgument
                        ;;
                        yes-argumented)
                            if [ $# -eq 0 ]; then
                                core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' requires an argument which was not specified";
                            fi;
                            local optionValue="$1";
                            shift 1;
                            core_commandLine_processOptionWithArgument
                        ;;
                        yes-optionally-argumented)
                            if [ $# -eq 0 ]; then
                                core_commandLine_processOptionWithoutArgument;
                                break;
                            fi;
                            local optionValue="$1";
                            if core_variable_startsWith "$optionValue" '--'; then
                                core_commandLine_processOptionWithoutArgument;
                            else
                                shift 1;
                                core_commandLine_processOptionWithArgument;
                            fi
                        ;;
                        no | '')
                            core_commandLine_exitBadCommandLine "The long option '${optionNameIncludingHyphens}' is not known"
                        ;;
                        *)
                            core_exitError $core_commandLine_exitCode_SOFTWARE "Please implement yes-argumented, yes-argumentless, yes-optionally-argumented or no for option '$optionName' in _program_commandLine_optionExists()"
                        ;;
                    esac
                ;;
                *)
                    core_exitError $core_commandLine_exitCode_SOFTWARE "The function core_commandLine_parse failed on argument '$argument', the line was '$@'"
                ;;
            esac;
        else
            if core_variable_startsWith "$argument" '-'; then
                if [ "$argument" = '-' ]; then
                    break;
                fi;
                shift 1;
                case "$argument" in 
                    -*=*)
                        local optionNameIncludingHyphens="${argument%%=*}";
                        local optionName="${optionNameIncludingHyphens##-}";
                        local optionValue="${argument#*=}";
                        if [ ${#optionNameIncludingHyphens} -gt 2 ]; then
                            core_commandLine_parseConcatenatedOptionsWithoutEquals;
                        fi;
                        case "$(core_commandLine_optionExists "$optionName")" in 
                            yes-argumentless)
                                core_commandLine_exitBadCommandLine "The option '$optionNameIncludingHyphens' does not take values (such as '$optionValue')"
                            ;;
                            yes-argumented | yes-optionally-argumented)
                                core_commandLine_processOptionWithArgument
                            ;;
                            no | '')
                                core_commandLine_exitBadCommandLine "The short option '$optionNameIncludingHyphens' is not known"
                            ;;
                            *)
                                core_exitError $core_commandLine_exitCode_SOFTWARE "Please implement yes-argumented, yes-argumentless, yes-optionally-argumented or no for option '$optionName' in _program_commandLine_optionExists()"
                            ;;
                        esac
                    ;;
                    -*)
                        local optionNameIncludingHyphens="$argument";
                        local optionName="${argument##-}";
                        if [ ${#optionNameIncludingHyphens} -gt 2 ]; then
                            local possibleOptionName="$(core_variable_firstCharacter "${optionName}")";
                            local possibleOptionValue="$(core_variable_allButFirst "${optionName}")";
                            case "$(core_commandLine_optionExists "$possibleOptionName")" in 
                                yes-argumented | yes-optionally-argumented)
                                    optionName="$possibleOptionName";
                                    optionValue="$possibleOptionValue";
                                    core_commandLine_processOptionWithArgument;
                                    continue
                                ;;
                            esac;
                            local shouldContinueAfterParsingConcatenatedOptions=0;
                            core_commandLine_parseConcatenatedOptionsWithoutEquals;
                            if [ $shouldContinueAfterParsingConcatenatedOptions ]; then
                                continue;
                            fi;
                        fi;
                        case "$(core_commandLine_optionExists "$optionName")" in 
                            yes-argumentless)
                                core_commandLine_processOptionWithoutArgument
                            ;;
                            yes-argumented)
                                if [ $# -eq 0 ]; then
                                    core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' requires an argument which was not specified";
                                fi;
                                local optionValue="$1";
                                shift 1;
                                core_commandLine_processOptionWithArgument
                            ;;
                            yes-optionally-argumented)
                                if [ $# -eq 0 ]; then
                                    core_commandLine_processOptionWithoutArgument;
                                    break;
                                fi;
                                local optionValue="$1";
                                if core_variable_startsWith "$optionValue" '--'; then
                                    core_commandLine_processOptionWithoutArgument;
                                else
                                    shift 1;
                                    core_commandLine_processOptionWithArgument;
                                fi
                            ;;
                            no | '')
                                core_commandLine_exitBadCommandLine "The short option '${optionNameIncludingHyphens}' is not known"
                            ;;
                            *)
                                core_exitError $core_commandLine_exitCode_SOFTWARE "Please implement yes-argumented, yes-argumentless, yes-optionally-argumented or no for option '$optionName' in _program_commandLine_optionExists()"
                            ;;
                        esac
                    ;;
                    *)
                        core_exitError $core_commandLine_exitCode_SOFTWARE "The function core_commandLine_parse failed on argument '$argument', the line was '$@'"
                    ;;
                esac;
            else
                break;
            fi;
        fi;
    done;
    _program_commandLine_handleNonOptions "$@";
    _program_commandLine_validate
}
core_commandLine_parseConcatenatedOptionsWithoutEquals () 
{ 
    local arguments="-${optionName}";
    local optstring=":${optionName}";
    local lastOption=${#optionName};
    local OPTARG;
    local OPTERR;
    local OPTIND=1;
    local possibleOptionName="$(core_variable_firstCharacter "${optionName}")";
    local possibleOptionValue="$(core_variable_allButFirst "${optionName}")";
    case "$(core_commandLine_optionExists "$possibleOptionName")" in 
        yes-argumented | yes-optionally-argumented)
            optionName="$possibleOptionName";
            optionValue="$possibleOptionValue";
            core_commandLine_processOptionWithArgument;
            shouldContinueAfterParsingConcatenatedOptions=1;
            return
        ;;
    esac;
    while getopts "$optstring" optionName "$arguments"; do
        optionNameIncludingHyphens="-${optionName}";
        argument="$optionNameIncludingHyphens";
        if [ $OPTIND -eq $lastOption ]; then
            return 0;
        fi;
        case "$(core_commandLine_optionExists "$optionName")" in 
            yes-argumentless | yes-optionally-argumented)
                core_commandLine_processOptionWithoutArgument
            ;;
            yes-argumented)
                core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' requires an argument which could not be specified"
            ;;
            no | '')
                core_commandLine_exitBadCommandLine "The short option (concatenated with others) '${optionNameIncludingHyphens}' is not known"
            ;;
            *)
                core_exitError $core_commandLine_exitCode_SOFTWARE "Please implement yes-argumented, yes-argumentless, yes-optionally-argumented or no for option '$optionName' in _program_commandLine_optionExists()"
            ;;
        esac;
    done
}
core_commandLine_processOptionWithArgument () 
{ 
    case "$optionName" in 
        v | verbose)
            core_validate_isUnsignedInteger $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            core_variable_setVariable ${_program_namespace}_verbose "$optionValue"
        ;;
        *)
            _program_commandLine_processOptionWithArgument
        ;;
    esac
}
core_commandLine_processOptionWithoutArgument () 
{ 
    case "$optionName" in 
        h | help)
            core_commandLine_exitHelp
        ;;
        v | verbose)
            local currentVerbosity=$(core_init_verbosity);
            core_variable_setVariable ${_program_namespace}_verbose $((currentVerbosity+1))
        ;;
        q | quiet)
            local currentVerbosity=$(core_init_verbosity);
            if [ $currentVerbosity -gt 0 ]; then
                core_variable_setVariable ${_program_namespace}_verbose $((currentVerbosity-1));
            fi
        ;;
        version)
            core_commandLine_exitVersion
        ;;
        *)
            _program_commandLine_processOptionWithoutArgument
        ;;
    esac
}
core_commandLine_setLanguageDefaults () 
{ 
    core_variable_unset LANG;
    core_variable_unset LC_COLLATE;
    core_variable_unset LC_CTYPE;
    core_variable_unset LC_MESSAGES;
    core_variable_unset LC_MONETARY;
    core_variable_unset LC_NUMERIC;
    core_variable_unset LC_TIME;
    core_variable_unset LC_ALL;
    local language="$(core_init_language)";
    export LANG="$language";
    export LC_COLLATE="$language";
    export LC_CTYPE="$language";
    export LC_MESSAGES="$language";
    export LC_MONETARY="$language";
    export LC_NUMERIC="$language";
    export LC_TIME="$language";
    export LC_ALL=""
}
core_commandLine_versionMessage () 
{ 
    if [ -z "$_program_package_or_build" ]; then
        local _program_package_or_build_x='';
    else
        local _program_package_or_build_x="($_program_package_or_build) ";
    fi;
    if core_variable_isSet _program_copyrightAndLicenseStatement; then
        local copyrightAndLicenseStatement="$_program_copyrightAndLicenseStatement";
    else
        local copyrightAndLicenseStatement="$(core_commandLine_defaultLicenseMessage)";
    fi;
    printf '%s' "$_program_name ${_program_package_or_build_x}$_program_version
Created using shellfire (https://github.com/shellfire-dev/shellfire)
$copyrightAndLicenseStatement"
}
core_compability_installPushdAndPopd () 
{ 
    if _core_compatibility_builtInDoesNotExist pushd; then
        if ! _core_compatibility_builtInDoesNotExist popd; then
            core_exitError $core_commandLine_exitCode_SOFTWARE "Weird shell does not have pushd but does have popd (?feature detection bug?)!";
        fi;
        _core_init_compatibility_pushdCount=0;
        pushd () 
        { 
            local path="$1";
            eval "core_init_pushdStack${_core_init_compatibility_pushdCount}='$(pwd)'";
            _core_init_compatibility_pushdCount=$((_core_init_compatibility_pushdCount+1));
            cd "$path" > /dev/null
        };
        popd () 
        { 
            _core_init_compatibility_pushdCount=$((_core_init_compatibility_pushdCount-1));
            eval "local path=\"\$core_init_pushdStack${_core_init_compatibility_pushdCount}\"";
            eval "unset core_init_pushdStack${_core_init_compatibility_pushdCount}";
            cd "$path" > /dev/null
        };
    else
        pushd () 
        { 
            builtin pushd "$@" > /dev/null
        };
        popd () 
        { 
            builtin popd "$@" > /dev/null
        };
    fi
}
core_compability_installSource () 
{ 
    if _core_compatibility_builtInDoesNotExist source; then
        source () 
        { 
            . "$@"
        };
    fi
}
core_compatibility_basename () 
{ 
    printf '%s' "${1##*/}"
}
core_compatibility_dirname () 
{ 
    local converted="${1%/*}";
    if [ "$converted" = "$1" ]; then
        printf '%s' '.';
    else
        printf '%s' "$converted";
    fi
}
core_compatibility_echo () 
{ 
    printf '%s\n' "$1"
}
core_compatibility_execute () 
{ 
    core_functions_execute _core_compatibility_functions
}
core_compatibility_setSaneShellOptions () 
{ 
    :
}
core_compatibility_sleepSupportsFractionalSeconds () 
{ 
    sleep 0.0001 2> /dev/null
}
core_compatibility_which () 
{ 
    command -v "$1"
}
core_compatibility_whichNoOutput () 
{ 
    core_compatibility_which "$1" > /dev/null 2> /dev/null
}
core_configuration_blacklist () 
{ 
    core_variable_array_append _core_configuration_blacklisted "$@"
}
core_configuration_defaults () 
{ 
    core_variable_setVariableIfUnset ${_program_namespace}_language $(core_init_language);
    core_variable_setVariableIfUnset ${_program_namespace}_verbose $(core_init_verbosity)
}
core_configuration_load () 
{ 
    core_variable_array_initialise _core_configuration_blacklisted;
    core_variable_array_initialise _core_configuration_alreadyLoaded;
    core_configuration_loadPath _program_etcPath "${core_libraryName}"/rc;
    core_configuration_loadPath _program_etcPath "${core_libraryName}"/rc.d;
    core_configuration_loadPath _program_etcPath "${_program_namespace}"/rc;
    core_configuration_loadPath _program_etcPath "${_program_namespace}"/rc.d;
    core_configuration_loadPath HOME ."${core_libraryName}"/rc;
    core_configuration_loadPath HOME ."${core_libraryName}"/rc.d;
    core_configuration_loadPath ${core_libraryName}_RC '';
    core_configuration_loadPath ${core_libraryName}_RC_D '';
    core_configuration_loadPath HOME ."${_program_namespace}"/rc;
    core_configuration_loadPath HOME ."${_program_namespace}"/rc.d;
    core_configuration_loadPath ${_program_namespace}_RC '';
    core_configuration_loadPath ${_program_namespace}_RC_D ''
}
core_configuration_loadPath () 
{ 
    local environmentVariable="$1";
    local folderOrFilePath="$2";
    if core_variable_isUnset "$environmentVariable"; then
        return 0;
    fi;
    if core_variable_array_isSet _core_configuration_blacklisted; then
        if core_variable_array_contains _core_configuration_blacklisted "$environmentVariable"; then
            core_message WARN "Configuration path '\$$environmentVariable/$folderOrFilePath' is blacklisted";
            return 0;
        fi;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$environmentVariable";
    local parentPath="$core_variable_indirectValue_result";
    if [ -z "$folderOrFilePath" ]; then
        local actualPath="$parentPath";
    else
        local actualPath="$parentPath"/"$folderOrFilePath";
    fi;
    if core_variable_array_contains _core_configuration_alreadyLoaded "$actualPath"; then
        return 0;
    fi;
    core_variable_array_append _core_configuration_alreadyLoaded "$actualPath";
    _core_configuration_load "$actualPath"
}
core_dependency_add () 
{ 
    local pathProgramName;
    local pathPackage;
    local pathAbsoluteFilePath;
    local foundInternally=0;
    _core_dependency_addFromInternalDataSource;
    if [ $foundInternally -eq 0 ]; then
        _core_dependency_addFromExternalDataSources;
    fi;
    if [ $foundInternally -eq 0 ]; then
        core_message INFO "Dependency '$programName' for packageManager '$packageManager' not in any known .path file (or internally)";
        return 0;
    fi;
    if [ "$(core_compatibility_basename "$pathAbsoluteFilePath")" = "$programName" ]; then
        return 0;
    fi;
    if [ -z "$temporaryPathForWeirdlyLinkedFiles" ]; then
        local TMP_FOLDER;
        core_temporaryFiles_newFolderToRemoveOnExit;
        temporaryPathForWeirdlyLinkedFiles="$TMP_FOLDER";
        replacementPath="$temporaryPathForWeirdlyLinkedFiles:$replacementPath";
    fi;
    ln -s "$pathAbsoluteFilePath" "$temporaryPathForWeirdlyLinkedFiles"/"$programName"
}
core_dependency_check_CentOS_checkFunction () 
{ 
    core_dependency_check_releaseFile centos-release CentOS
}
core_dependency_check_CentOS_extractUnqualifiedPackageName () 
{ 
    local fullyQualifiedPackageName="$1";
    local repositoryName;
    local packageName;
    _core_dependency_check_CentOS_parsePackageName;
    printf '%s' "$packageName"
}
core_dependency_check_CentOS_packageManager () 
{ 
    if [ $(core_init_verbosity) -gt 0 ]; then
        local yumVerbosity="";
    else
        local yumVerbosity="--quiet";
    fi;
    sudo -p "Please enter the password for %p for sudo to update yum: " yum ${yumVerbosity} makecache;
    local repositoryName;
    local packageName;
    local fullyQualifiedPackageName;
    local functionName;
    for fullyQualifiedPackageName in "$@";
    do
        _core_dependency_check_CentOS_parsePackageName;
        if [ -z "$repositoryName" ]; then
            sudo -p "Please enter the password for %p for sudo to run yum install $packageName: " yum ${yumVerbosity} -y install "$packageName";
        else
            functionName=_core_dependency_check_CentOS_installRepository_${repositoryName};
            if ! core_functions_exists "$functionName"; then
                core_exitError "Package '$packageName' is in an unsupported repository '$repositoryName'";
            else
                ${functionName};
            fi;
            if [ "$repositoryName" = 'repoforge' ]; then
                repositoryName=rpmforge;
            fi;
            sudo -p "Please enter the password for %p for sudo to run yum install $packageName: " yum ${yumVerbosity} -y --disablerepo="*" --enablerepo="$repositoryName" install "$packageName";
        fi;
    done
}
core_dependency_check_Cygwin_checkFunction () 
{ 
    if [ -x /bin/cygcheck.exe ]; then
        core_dependency_packageManager="Cygwin";
        return 0;
    fi;
    return 1
}
core_dependency_check_Cygwin_extractUnqualifiedPackageName () 
{ 
    local fullyQualifiedPackageName="$1";
    printf '%s' "$fullyQualifiedPackageName"
}
core_dependency_check_Cygwin_packageManager () 
{ 
    core_exitError $core_commandLine_exitCode_CONFIG "Please run the Cygwin setup-x86.exe to install the packages $@"
}
core_dependency_check_Debian_checkFunction () 
{ 
    core_dependency_check_releaseFile debian_version Debian
}
core_dependency_check_Debian_extractUnqualifiedPackageName () 
{ 
    local fullyQualifiedPackageName="$1";
    printf '%s' "$fullyQualifiedPackageName"
}
core_dependency_check_Debian_packageManager () 
{ 
    if [ $(core_init_verbosity) -gt 0 ]; then
        local aptVerbosity="";
    else
        local aptVerbosity=" --quiet";
    fi;
    core_message NOTICE "Updating apt-get package manager (may take some time)";
    sudo -p "Please enter the password for %p for sudo to apt-get update: " apt-get${aptVerbosity} update;
    if core_variable_isSet core_dependency_check_forcePackageManagerUpgradeDuringInstall; then
        if [ $core_dependency_check_forcePackageManagerUpgradeDuringInstall -eq 1 ]; then
            core_message INFO "Upgrading apt-get package manager (may take some time)";
            sudo -p "Please enter the password for %p for sudo to run apt-get dist-upgrade: " apt-get${aptVerbosity} dist-upgrade;
        fi;
    fi;
    sudo -p "Please enter the password for %p for sudo to run apt-get install: " apt-get${aptVerbosity} --no-install-recommends --yes --no-upgrade install "$@"
}
core_dependency_check_Fedora_checkFunction () 
{ 
    core_dependency_check_releaseFile fedora-release Fedora
}
core_dependency_check_Fedora_extractUnqualifiedPackageName () 
{ 
    core_dependency_check_CentOS_extractUnqualifiedPackageName "$@"
}
core_dependency_check_Fedora_packageManager () 
{ 
    core_dependency_check_CentOS_packageManager "$@"
}
core_dependency_check_Homebrew_checkFunction () 
{ 
    if core_compatibility_whichNoOutput brew; then
        core_dependency_packageManager="Homebrew";
        return 0;
    fi;
    return 1
}
core_dependency_check_Homebrew_extractUnqualifiedPackageName () 
{ 
    local fullyQualifiedPackageName="$1";
    core_compatibility_basename "$fullyQualifiedPackageName"
}
core_dependency_check_Homebrew_installPackageManagerIfRequired () 
{ 
    if core_compatibility_whichNoOutput brew; then
        return 0;
    fi;
    core_message NOTICE "Installing Homebrew package manager";
    ruby -e "$(curl -fsSL 'https://raw.githubusercontent.com/Homebrew/install/master/install')";
    core_message INFO "Doctoring (sic) Homebrew package manager";
    brew doctor
}
core_dependency_check_Homebrew_packageManager () 
{ 
    _core_dependency_check_Homebrew_packageManager_tapExists () 
    { 
        local existingTap;
        brew tap | while IFS='' read -r existingTap; do
            if [ "$existingTap" = "$tap" ]; then
                return 0;
            fi;
        done;
        return 1
    };
    local packageToInstall;
    local package;
    _core_dependency_check_Homebrew_packageManager_installTaps () 
    { 
        local tap;
        for packageToInstall in "$@";
        do
            tap="$(core_compatibility_dirname "$packageToInstall")";
            if [ "$tap" = '.' ]; then
                continue;
            fi;
            if _core_dependency_check_Homebrew_packageManager_tapExists; then
                continue;
            fi;
            brew tap "$tap" > /dev/null 2> /dev/null;
        done
    };
    _core_dependency_check_Homebrew_packageManager_installTaps "$@";
    core_message NOTICE "Updating Homebrew package manager (may take some time)";
    brew update;
    if core_variable_isSet core_dependency_check_forcePackageManagerUpgradeDuringInstall; then
        if [ $core_dependency_check_forcePackageManagerUpgradeDuringInstall -eq 1 ]; then
            core_message INFO "Upgrading Homebrew package manager (may take some time)";
            brew upgrade;
        fi;
    fi;
    for packageToInstall in "$@";
    do
        package="$(core_compatibility_basename "$packageToInstall")";
        if brew --prefix "$package" > /dev/null 2> /dev/null; then
            local checkFolderPath="$(brew --prefix "$package")";
            if [ -d "$checkFolderPath" ]; then
                continue;
            fi;
        fi;
        brew install "$package";
    done
}
core_dependency_check_RedHat_checkFunction () 
{ 
    core_dependency_check_releaseFile redhat-release RedHat
}
core_dependency_check_RedHat_extractUnqualifiedPackageName () 
{ 
    core_dependency_check_CentOS_extractUnqualifiedPackageName "$@"
}
core_dependency_check_RedHat_packageManager () 
{ 
    core_dependency_check_CentOS_packageManager "$@"
}
core_dependency_check_SuSE_checkFunction () 
{ 
    core_dependency_check_releaseFile SuSE-release SuSE
}
core_dependency_check_SuSE_extractUnqualifiedPackageName () 
{ 
    core_dependency_check_CentOS_extractUnqualifiedPackageName "$@"
}
core_dependency_check_SuSE_packageManager () 
{ 
    if [ $# -eq 0 ]; then
        return 0;
    fi;
    sudo -p "Please enter the password for %p for sudo to run zypper install: " zypper install "$@"
}
core_dependency_check_releaseFile () 
{ 
    local releaseFileName="$1";
    local packageManager="$2";
    if [ -f /etc/"$releaseFileName" ]; then
        core_dependency_packageManager="$packageManager";
        return 0;
    fi;
    return 1
}
core_dependency_declares () 
{ 
    :
}
core_dependency_declaresAsArray () 
{ 
    local variableName;
    for variableName in "$@";
    do
        _program_fattening_declares "$variableName";
        _program_fattening_declares "${variableName}_initialised";
    done
}
core_dependency_determinePackageManager () 
{ 
    if core_variable_array_iterateAsCallbacksShortcut _core_dependency_check_functions; then
        return 0;
    fi;
    if core_compatibility_whichNoOutput lsb_release; then
        local lsbDistributor="$(lsb_release --id --short)";
        if [ -n "$lsbDistributor" ]; then
            core_dependency_packageManager="$lsbDistributor";
            return 0;
        fi;
    fi;
    core_dependency_packageManager='Unknown'
}
core_dependency_fallback () 
{ 
    _local_condition="$1";
    for _local_programNameOnPath in "$@";
    do
        :;
    done;
    unset _local_condition;
    unset _local_programNameOnPath
}
core_dependency_installDependencies () 
{ 
    if core_variable_isUnset _program_ignoreDependencies; then
        _program_ignoreDependencies=no;
    fi;
    if core_variable_isFalse "$_program_ignoreDependencies"; then
        core_functions_execute _core_dependency_functions "$@";
    fi
}
core_dependency_oneOf () 
{ 
    _local_packageManager="$1";
    if [ -z "$_local_packageManager" ]; then
        core_exitError 70 "packageManager can not be empty";
    fi;
    shift 1;
    for _local_programName in "$@";
    do
        :;
    done;
    unset _local_packageManager;
    unset _local_programName
}
core_dependency_requires () 
{ 
    _local_packageManager="$1";
    if [ -z "$_local_packageManager" ]; then
        core_exitError 70 "packageManager can not be empty";
    fi;
    shift 1;
    for _local_programName in "$@";
    do
        if [ -z "$_local_programName" ]; then
            core_exitError 70 "programName can not be empty";
        fi;
        _core_dependency_requires="${_core_dependency_requires}${_local_packageManager} ${_local_programName}
";
        core_message DEBUG "Requires in packageManager '$_local_packageManager' program '$_local_programName'";
    done;
    unset _local_packageManager;
    unset _local_programName
}
core_dependency_setUpPathAndInstallMissing () 
{ 
    local replacementPath='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin';
    _core_dependency_addToReplacementPathIfRequired "$core_init_ourSymlinkPath";
    _core_dependency_addToReplacementPathIfRequired "$core_init_ourPath";
    if [ "$core_dependency_packageManager" = 'Unknown' ]; then
        core_message INFO 'Could not determine package manager for your system, located binaries may be incorrect';
    fi;
    local alreadyHandledProgramNames;
    local alreadyHandledProgramNames_initialised;
    core_variable_array_initialise alreadyHandledProgramNames;
    local packagesToInstall;
    local packagesToInstall_initialised;
    core_variable_array_initialise packagesToInstall;
    local temporaryPathForWeirdlyLinkedFiles='';
    local packageManager;
    local programName;
    local alreadyInstalledProgramName;
    local originalIFS="$IFS";
    local IFS=' ';
    while IFS=' ' read -r packageManager programName; do
        IFS="$originalIFS";
        case "$packageManager" in 
            '*' | "$core_dependency_packageManager")
                packageManager="$core_dependency_packageManager";
                if core_variable_array_contains alreadyHandledProgramNames "$programName"; then
                    continue;
                fi;
                core_variable_array_append alreadyHandledProgramNames "$programName";
                core_dependency_add
            ;;
            '')
                break
            ;;
            *)
                continue
            ;;
        esac;
    done  <<-EOF
${_core_dependency_requires}
EOF

    IFS="$originalIFS";
    if ! core_variable_array_isEmpty packagesToInstall; then
        core_message WARN "Installing missing packages '$(core_variable_array_string packagesToInstall " ")'";
        core_variable_array_passToFunctionAsArguments packagesToInstall core_dependency_check_${core_dependency_packageManager}_packageManager;
    fi;
    export PATH="$replacementPath"
}
core_exitError () 
{ 
    core_message FAIL "$2";
    exit $1
}
core_file_characterByCharacter () 
{ 
    local filePath="$1";
    shift 1;
    local TMP_FILE;
    core_temporaryFiles_newFileToRemoveOnExit;
    local singleCharactersFile="$TMP_FILE";
    core_file_characterByCharacterCreate "$filePath" "$singleCharactersFile";
    local callback;
    local character;
    { 
        while IFS='' read -r character; do
            for callback in "$@";
            do
                $callback;
            done;
        done
    } < "$singleCharactersFile";
    rm -f "$singleCharactersFile"
}
core_file_characterByCharacterCreate () 
{ 
    local inputFile="$1";
    local outputFile="$2";
    awk '
BEGIN {
	srand()
	FS=""
	RS="n/o/m/a/t/c/h" rand()
}

{
	for (i = 1; i <= NF; i++)
	{
		if ($i ~ /\n/)
		{
			printf "\n"
		}
		else
		{
			print $i
		}
	}
}' < "$inputFile" > "$outputFile"
}
core_functions_execute () 
{ 
    local functionsVariableName="$1";
    shift 1;
    if core_variable_isSet "$functionsVariableName"; then
        core_variable_array_iterateAsCallbacks "$functionsVariableName" "$@";
    fi
}
core_functions_exists () 
{ 
    local functionName="$1";
    if ! type "$functionName" > /dev/null 2> /dev/null; then
        return 1;
    fi;
    local arg0;
    local arg1;
    local arg2;
    local arg3;
    local arg4;
    IFS=' ' read -r arg0 arg1 arg2 arg3 arg4  <<-EOF
$(type "$functionName")
EOF

    case "$arg3" in 
        shell)
            if [ "$arg4" = 'function' ]; then
                return 0;
            fi
        ;;
        function)
            return 0
        ;;
        'function.')
            return 0
        ;;
    esac;
    return 1
}
core_functions_register () 
{ 
    local functionsVariableName="$1";
    shift 1;
    core_variable_array_append "$functionsVariableName" "$@";
    core_dependency_declaresAsArray "$functionsVariableName"
}
core_init_defines () 
{ 
    :
}
core_init_determinePreferredShell () 
{ 
    IFS=' ' read -r _local_commented_shebang_path _local_shebang_shell _local_remainder < "$core_init_ourSymlinkExecutablePath";
    if [ -n "$_local_remainder" ]; then
        core_exitError 70 "Passing options to a shell ('#!$_local_shebang_path $_local_shebang_shell $_local_remainder') is not supported";
    fi;
    IFS='!' read -r _local_comment _local_shebang_path  <<-EOF
$_local_commented_shebang_path
EOF

    if [ -z "$_local_shebang_shell" ]; then
        core_init_shellPreferred="$(core_compatibility_basename "$_local_shebang_path")";
    else
        if [ "$_local_shebang_path" != '/usr/bin/env' ]; then
            core_exitError 70 "All shell scripts should use '/usr/bin/env' with a shell, not #!$_local_shebang_path $shebang_shell";
        fi;
        core_init_shellPreferred="$_local_shebang_shell";
    fi;
    unset _local_commented_shebang_path;
    unset _local_shebang_shell;
    unset _local_remainder;
    unset _local_comment;
    unset _local_shebang_path
}
core_init_doNotRunAsSetUidOrSetGid () 
{ 
    if [ -u "$core_init_ourSymlinkExecutablePath" ]; then
        core_exitError 77 "We can not be run with the setuid bit set";
    fi;
    if [ -g "$core_init_ourSymlinkExecutablePath" ]; then
        core_exitError 77 "We can not be run with setgid bit set";
    fi
}
core_init_enableShellTweaks () 
{ 
    core_variable_unset () 
    { 
        unset "$@"
    };
    case "$core_init_shellDetected" in 
        ksh93)
            alias local='typeset'
        ;;
        pdksh)
            core_variable_unset () 
            { 
                set +e;
                unset "$1";
                set -e
            };
            set +u
        ;;
        mksh)
            set +u
        ;;
        yash)
            alias local='typeset'
        ;;
    esac
}
core_init_findOurNameAndPath () 
{ 
    core_init_ourSymlinkName="$(core_compatibility_basename "$0")";
    _local_ourSymlinkPathRaw="${0%/*}";
    if [ -z "$_local_ourSymlinkPathRaw" ]; then
        core_exitError 64 "Do not invoke this program either by specifying a shell interpreter on a file in the current working directory (eg bash '$0') or redirecting from a pipe into a shell interpreter (eg bash [-c] <'$0') or by using ksh with a PATH containing '.'";
    else
        if [ "$_local_ourSymlinkPathRaw" = "$0" ]; then
            core_exitError 64 "Do not invoke this program either by specifying a shell interpreter on a file in the current working directory (eg bash '$0') or redirecting from a pipe into a shell interpreter (eg bash [-c] <'$0') or by using ksh with a PATH containing '.'";
        fi;
    fi;
    cd "$_local_ourSymlinkPathRaw" > /dev/null;
    core_init_ourSymlinkPath="$(pwd)";
    core_init_ourPath="$(pwd -P)";
    cd - > /dev/null;
    core_init_ourSymlinkExecutablePath="$core_init_ourSymlinkPath"/"$core_init_ourSymlinkName";
    unset _local_ourSymlinkPathRaw
}
core_init_init () 
{ 
    set -e;
    set -u;
    if [ "${_program_namespace+set}" != 'set' ]; then
        _program_namespace="${_program_name}";
    fi
}
core_init_initialiseArrayDelimiter () 
{ 
    if core_variable_isSet core_variable_array_delimiter; then
        return 0;
    fi;
    if core_variable_isSet _program_arrayDelimiter; then
        core_variable_array_delimiter="$_program_arrayDelimiter";
    else
        core_variable_array_delimiter="$(printf '\r')";
    fi;
    core_dependency_declares core_variable_array_delimiter
}
core_init_isFattening () 
{ 
    core_variable_isSet _program_fattening
}
core_init_language () 
{ 
    if core_variable_isSet ${_program_namespace}_language; then
        local core_variable_indirectValue_result;
        core_variable_indirectValue ${_program_namespace}_language;
        printf '%s' $core_variable_indirectValue_result;
    else
        printf '%s' 'en_US.UTF-8';
    fi
}
core_init_main () 
{ 
    core_init_init;
    core_init_shellDetection;
    core_init_enableShellTweaks;
    core_init_setSaneEnvironmentDefaults;
    core_init_findOurNameAndPath;
    core_init_determinePreferredShell;
    core_init_rexecUnderCorrectShell "$@";
    core_init_initialiseArrayDelimiter;
    core_usesIn core;
    if core_functions_exists _program; then
        _program;
    else
        :;
    fi;
    if core_init_isFattening; then
        return 0;
    fi;
    core_functions_execute _core_functions "$@";
    ${_program_entrypoint}
}
core_init_rexecUnderCorrectShell () 
{ 
    if core_variable_isSet core_init_shell_rexecing; then
        if [ "$core_init_shell_rexecing" = "$$" ]; then
            unset core_init_shell_rexecing;
            return 0;
        fi;
    fi;
    if [ "$core_init_shellDetected" = "$core_init_shellPreferred" ]; then
        return 0;
    fi;
    if ! core_compatibility_whichNoOutput "$core_init_shellPreferred"; then
        core_exitError 72 "Preferred shell '$core_init_shellPreferred' does not exist on the PATH";
    fi;
    _local_shellPath="$(core_compatibility_which "$core_init_shellPreferred")";
    if [ "$core_init_shellDetected" = 'bash' ]; then
        export core_init_shell_rexecing=$$;
        exec "$_local_shellPath" -p "$core_init_ourSymlinkExecutablePath" "$@";
    else
        export core_init_shell_rexecing=$$;
        core_init_shell_rexecing=$$ exec "$_local_shellPath" "$core_init_ourSymlinkExecutablePath" "$@";
    fi;
    unset _local_shellPath
}
core_init_setSaneEnvironmentDefaults () 
{ 
    set +o allexport;
    set +o emacs;
    set -o errexit;
    set +o ignoreeof;
    set +o monitor;
    set +o noclobber;
    set +o noexec;
    set -o noglob;
    set +o notify;
    set +o verbose;
    set +o vi;
    core_variable_unset CDPATH;
    core_variable_unset HISTSIZE;
    core_variable_unset MAILCHECK;
    core_variable_unset MAILPATH;
    core_variable_unset ENV;
    core_variable_unset BASH_ENV;
    core_variable_unset BASH_XTRACEFD;
    core_variable_unset FCEDIT;
    core_variable_unset FIGNORE;
    core_variable_unset FUNCNEST;
    core_variable_unset GLOBIGNORE;
    core_variable_unset HISTCONTROL;
    core_variable_unset HISTFILE;
    core_variable_unset HISTFILESIZE;
    core_variable_unset HISTIGNORE;
    core_variable_unset HISTTIMEFORMAT;
    core_variable_unset HOSTFILE;
    core_variable_unset IGNOREEOF;
    core_variable_unset INPUTRC;
    core_variable_unset MAIL;
    core_variable_unset TMOUT
}
core_init_shellDetection () 
{ 
    if [ "${KSH_VERSION+set}" = 'set' ]; then
        _local_core_init_shellDetection_kshVersion="$KSH_VERSION";
    else
        if [ "${SH_VERSION+set}" = 'set' ]; then
            _local_core_init_shellDetection_kshVersion="$SH_VERSION";
        else
            _local_core_init_shellDetection_kshVersion='';
        fi;
    fi;
    if [ -n "$_local_core_init_shellDetection_kshVersion" ]; then
        IFS=' ' read -r _local_core_init_shellDetection_version _local_core_init_shellDetection_garbage  <<-EOF
${_local_core_init_shellDetection_kshVersion}
EOF

        case "$_local_core_init_shellDetection_version" in 
            'Version' | '.sh.version')
                core_init_shellDetected=ksh93
            ;;
            '@(#)PD')
                core_init_shellDetected=pdksh
            ;;
            '@(#)MIRBSD')
                core_init_shellDetected=mksh
            ;;
            *)
                core_init_shellDetected=unknown-ksh
            ;;
        esac;
        unset _local_core_init_shellDetection_version;
        unset _local_core_init_shellDetection_garbage;
    else
        if [ "${BASH_VERSION+set}" = 'set' ]; then
            core_init_shellDetected=bash;
        else
            if [ "${ZSH_VERSION+set}" = 'set' ]; then
                core_init_shellDetected=zsh;
            else
                if [ "${YASH_VERSION+set}" = 'set' ]; then
                    core_init_shellDetected=yash;
                else
                    core_init_shellDetected=sh;
                fi;
            fi;
        fi;
    fi;
    unset _local_core_init_shellDetection_kshVersion
}
core_init_verbosity () 
{ 
    if core_variable_isSet ${_program_namespace}_verbose; then
        local core_variable_indirectValue_result;
        core_variable_indirectValue ${_program_namespace}_verbose;
        printf '%s' $core_variable_indirectValue_result;
    else
        printf '%s' 0;
    fi
}
core_message () 
{ 
    local messageKind="$1";
    local message="$2";
    local shouldEcho=0;
    local prefix='';
    case "$messageKind" in 
        FAIL)
            prefix="$(core_terminal_effect 2 bold)$(core_terminal_colour 2 foreground red)";
            shouldEcho=1
        ;;
        WARN)
            prefix="$(core_terminal_effect 2 bold)$(core_terminal_colour 2 foreground yellow)";
            shouldEcho=1
        ;;
        NOTICE)
            if [ $(core_init_verbosity) -gt 0 ]; then
                prefix="$(core_terminal_colour 2 foreground cyan)";
                shouldEcho=1;
            fi
        ;;
        INFO)
            if [ $(core_init_verbosity) -gt 1 ]; then
                prefix="$(core_terminal_colour 2 foreground white)";
                shouldEcho=1;
            fi
        ;;
        TODO)
            if [ $(core_init_verbosity) -gt 1 ]; then
                prefix="$(core_terminal_effect 2 dim)";
                shouldEcho=1;
            fi
        ;;
        DEBUG)
            if [ $(core_init_verbosity) -gt 2 ]; then
                prefix="$(core_terminal_effect 2 dim)$(core_terminal_colour 2 foreground magenta)";
                shouldEcho=1;
            fi
        ;;
        *)
            shouldEcho=1
        ;;
    esac;
    if [ $shouldEcho -eq 1 ]; then
        printf '%s%s%s\n' "$prefix" "$_program_name: $messageKind: $message" "$(core_terminal_reset 2)" 1>&2;
    fi
}
core_path_isReadableAndSearchableAndWritableFolderPath () 
{ 
    core_path_isReadableAndSearchableFolderPath "$1";
    local folderPath="$1";
    if [ -w "$folderPath" ]; then
        return 0;
    fi;
    return 1
}
core_path_isReadableAndSearchableFolderPath () 
{ 
    local folderPath="$1";
    if [ ! -e "$folderPath" ]; then
        return 1;
    fi;
    if [ ! -d "$folderPath" ]; then
        return 1;
    fi;
    if [ ! -r "$folderPath" ]; then
        return 1;
    fi;
    if [ -x "$folderPath" ]; then
        return 0;
    fi;
    return 1
}
core_path_isReadableFilePath () 
{ 
    local filePath="$1";
    if [ ! -e "$filePath" ]; then
        return 1;
    fi;
    if [ ! -f "$filePath" ]; then
        return 1;
    fi;
    if [ -r "$filePath" ]; then
        return 0;
    fi;
    return 1
}
core_path_isReadableNonEmptyExecutableFilePath () 
{ 
    local filePath="$1";
    core_path_isReadableNonEmptyFilePath "$filePath";
    if [ -x "$filePath" ]; then
        return 0;
    fi;
    return 1
}
core_path_isReadableNonEmptyFilePath () 
{ 
    local filePath="$1";
    core_path_isReadableFilePath "$filePath";
    if [ -s "$filePath" ]; then
        return 0;
    fi;
    return 1
}
core_snippet_base64_decoder () 
{ 
    core_base64_decode_string "$(core_variable_indirectValue _core_snippet_embeddedData_${snippetName})" "$snippetFilePath" "$snippetAppend" '+' '/'
}
core_snippet_base64_encoder () 
{ 
    _core_snippet_embeddedData_${snippetName}="$(base64 "$snippetFilePath" | tr -d '\n')"
}
core_snippet_embed () 
{ 
    local codecName="$1";
    shift 1;
    local encoder="core_snippet_${codecName}_encoder";
    local snippetName;
    local snippetFilePath;
    for snippetName in "$@";
    do
        if core_variable_isSet _core_snippet_embeddedData_${snippetName}; then
            continue;
        fi;
        snippetFilePath="$_program_libPath"/"$core_libraryName"/"${_program_namespace}"/"$snippetName".snippet;
        if ! core_path_isReadableNonEmptyFilePath "$snippetFilePath"; then
            core_exitError $core_commandLine_exitCode_SOFTWARE "Snippet '$snippetName' does not exist as a readable, non-empty file at '$snippetFilePath'";
        fi;
        ${encoder};
        core_dependency_declares _core_snippet_embeddedData_${snippetName};
        core_variable_setVariable _core_snippet_embeddedCodec_${snippetName} $codecName;
        core_dependency_declares _core_snippet_embeddedCodec_${snippetName};
    done
}
core_snippet_raw_decoder () 
{ 
    local core_variable_indirectValue_result;
    core_variable_indirectValue _core_snippet_embeddedData_${snippetName};
    if core_variable_isTrue "$snippetAppend"; then
        printf '%s' "$core_variable_indirectValue_result" >> "$snippetFilePath";
    else
        printf '%s' "$core_variable_indirectValue_result" > "$snippetFilePath";
    fi
}
core_snippet_raw_encoder () 
{ 
    core_variable_setVariable _core_snippet_embeddedData_${snippetName} "$(<"$snippetFilePath")"
}
core_snippet_retrieve () 
{ 
    local snippetName="$1";
    local snippetAppend="$2";
    local snippetFilePath="$3";
    local core_variable_indirectValue_result;
    local codec;
    local decoder;
    core_variable_indirectValue _core_snippet_embeddedCodec_${snippetName};
    codec="$core_variable_indirectValue_result";
    decoder="core_snippet_${codec}_decoder";
    ${decoder}
}
core_snippet_retrieveAndSourceAsHereDoc () 
{ 
    local snippetName="$1";
    local TMP_FILE;
    core_temporaryFiles_newFileToRemoveOnExit;
    local snippetFilePath="$TMP_FILE";
    printf '%s\n' 'cat <<EOF' > "$snippetFilePath";
    core_snippet_retrieve "$snippetName" yes "$snippetFilePath";
    printf '\nEOF' >> "$snippetFilePath";
    . "$snippetFilePath";
    rm "$snippetFilePath" || true
}
core_temporaryFiles_initialise () 
{ 
    core_trap_addOnCleanUp core_temporaryFiles_removeAll;
    if core_variable_isUnset TMPDIR; then
        if core_variable_isSet TMP; then
            TMPDIR="$TMP";
        else
            if core_variable_isSet TEMP; then
                TMPDIR="$TEMP";
            else
                core_message NOTICE "Defaulting TMPDIR to '/tmp'";
                TMPDIR='/tmp';
            fi;
        fi;
    else
        if core_variable_endsWith "$TMPDIR" '/'; then
            TMPDIR="$(core_variable_allButLast "$TMPDIR")";
        fi;
    fi;
    core_validate_folderPathReadableAndSearchableAndWritable $core_commandLine_exitCode_CONFIG "environment variable (or default, '/tmp')" 'TMPDIR' "$TMPDIR";
    if core_compatibility_whichNoOutput mktemp; then
        core_temporaryFiles_newFileToRemoveOnExit () 
        { 
            local umaskOriginal="$(umask)";
            umask 077;
            TMP_FILE="$(mktemp "$TMPDIR"/"$_program_name".XXXXXXXXXXXX)" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary file";
            core_variable_array_append _core_temporaryFiles_filesToRemoveOnExit "$TMP_FILE";
            umask "$umaskOriginal"
        };
        core_temporaryFiles_newFolderToRemoveOnExit () 
        { 
            local umaskOriginal="$(umask)";
            umask 077;
            TMP_FOLDER="$(mktemp -d "$TMPDIR"/"$_program_name".XXXXXXXXXXXX)" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary folder";
            core_variable_array_append _core_temporaryFiles_filesToRemoveOnExit "$TMP_FOLDER";
            umask "$umaskOriginal"
        };
        return 0;
    fi;
    if core_variable_isSet RANDOM; then
        core_message WARN "Your system doesn't have mktemp - we're creating temporary files INSECURELY in '$TMPDIR' using process id and 'RANDOM'";
        core_temporaryFiles_newFileToRemoveOnExit () 
        { 
            local umaskOriginal="$(umask)";
            umask 077;
            TMP_FILE="$TMPDIR"/"${_program_name}.file.$$.${RANDOM}";
            printf '' > "$TMP_FILE" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary file";
            core_variable_array_append _core_temporaryFiles_filesToRemoveOnExit "$TMP_FILE";
            umask "$umaskOriginal"
        };
        core_temporaryFiles_newFolderToRemoveOnExit () 
        { 
            local umaskOriginal="$(umask)";
            umask 077;
            TMP_FOLDER="$TMPDIR"/"${_program_name}.folder.$$.${RANDOM}";
            mkdir -m 0700 -p "$TMP_FOLDER" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary folder";
            core_variable_array_append _core_temporaryFiles_filesToRemoveOnExit "$TMP_FOLDER";
            umask "$umaskOriginal"
        };
        return 0;
    fi;
    if core_variable_isSet HOME; then
        if ! core_path_isReadableAndSearchableAndWritableFolderPath "$HOME"; then
            core_exitError $core_commandLine_exitCode_CANTCREAT "Your shell doesn't have RANDOM, mktemp isn't available and your HOME '$HOME' isn't writable. We've got no where left to put temporary files.";
        fi;
        TMPDIR="$HOME"/"$_program_name/$$";
        core_message WARN "Your shell doesn't have RANDOM, and mktemp isn't available. - we're creating temporary files beneath your HOME at '$TMPDIR'";
        rm -rf "$TMPDIR" 2> /dev/null || true;
        mkdir -m 0700 "$TMPDIR" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary folder";
        core_variable_array_append _core_temporaryFiles_filesToRemoveOnExit "$TMPDIR";
        _core_temporaryFiles_fileCounter=0;
        core_temporaryFiles_newFileToRemoveOnExit () 
        { 
            local umaskOriginal="$(umask)";
            umask 077;
            TMP_FILE="$TMPDIR"/file."$_core_temporaryFiles_fileCounter";
            _core_temporaryFiles_fileCounter=$((_core_temporaryFiles_fileCounter+1));
            printf '' > "$TMP_FILE" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary file";
            umask "$umaskOriginal"
        };
        _core_temporaryFiles_folderCounter=0;
        core_temporaryFiles_newFolderToRemoveOnExit () 
        { 
            local umaskOriginal="$(umask)";
            umask 077;
            TMP_FOLDER="$TMPDIR"/folder."$_core_temporaryFiles_folderCounter";
            _core_temporaryFiles_folderCounter=$((_core_temporaryFiles_folderCounter+1));
            mkdir -m 0700 -p "$TMP_FOLDER" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary folder";
            umask "$umaskOriginal"
        };
        return 0;
    fi;
    core_exitError $core_commandLine_exitCode_CANTCREAT "Your shell doesn't have RANDOM, mktemp isn't available and your HOME isn't set. We've got no where left to put temporary files."
}
core_temporaryFiles_removeAll () 
{ 
    if core_variable_array_isSet _core_temporaryFiles_filesToRemoveOnExit; then
        core_variable_array_passToFunctionAsArguments _core_temporaryFiles_filesToRemoveOnExit _core_temporaryFiles_removeAll_callback;
    fi
}
core_terminal_ansiSequence () 
{ 
    IFS='' printf "\033[${1}m"
}
core_terminal_ansiSupported () 
{ 
    case "$TERM" in 
        xterm* | rxvt* | urxvt* | linux* | vt*)
            return 0
        ;;
    esac;
    return 1
}
core_terminal_colour () 
{ 
    if [ ! -t $1 ]; then
        return 0;
    fi;
    local terminfoCommand;
    local ansiGroundCodeBit;
    case "$2" in 
        foreground)
            terminfoCommand=setaf;
            ansiGroundCodeBit=3
        ;;
        background)
            terminfoCommand=setbf;
            ansiGroundCodeBit=4
        ;;
    esac;
    local ansiColorCodeBit;
    case "$3" in 
        black)
            ansiColorCodeBit=0
        ;;
        red)
            ansiColorCodeBit=1
        ;;
        green)
            ansiColorCodeBit=2
        ;;
        yellow)
            ansiColorCodeBit=3
        ;;
        blue)
            ansiColorCodeBit=4
        ;;
        magenta)
            ansiColorCodeBit=5
        ;;
        cyan)
            ansiColorCodeBit=6
        ;;
        white)
            ansiColorCodeBit=7
        ;;
        default)
            ansiColorCodeBit=9
        ;;
    esac;
    if core_terminal_ansiSupported; then
        core_terminal_ansiSequence ${ansiGroundCodeBit}${ansiColorCodeBit};
    else
        if core_compatibility_whichNoOutput tput; then
            core_terminal_tput $terminfoCommand $ansiColorCodeBit;
        fi;
    fi
}
core_terminal_effect () 
{ 
    if [ ! -t $1 ]; then
        return 0;
    fi;
    shift 1;
    local effect;
    local terminfoCommand;
    local ansiCode;
    for effect in "$@";
    do
        case "$effect" in 
            bold)
                terminfoCommand=bold;
                ansiCode=1
            ;;
            dim)
                terminfoCommand=dim;
                ansiCode=2
            ;;
            blink)
                terminfoCommand=blink;
                ansiCode=5
            ;;
            reversed)
                terminfoCommand=rev;
                ansiCode=7
            ;;
            invisible)
                terminfoCommand=invis;
                ansiCode=8
            ;;
        esac;
        if core_terminal_ansiSupported; then
            core_terminal_ansiSequence $ansiCode;
        else
            if core_compatibility_whichNoOutput tput; then
                core_terminal_tput $terminfoCommand;
            fi;
        fi;
    done
}
core_terminal_reset () 
{ 
    if [ -t $1 ]; then
        if core_terminal_ansiSupported; then
            core_terminal_ansiSequence 0;
        else
            if core_compatibility_whichNoOutput tput; then
                core_terminal_tput sgr0;
            fi;
        fi;
    fi
}
core_terminal_tput () 
{ 
    tput -T"${TERM:-dumb}" "$@" 2> /dev/null || true
}
core_trap_addHandler () 
{ 
    local handler="$1";
    shift 1;
    local trapName;
    for trapName in "$@";
    do
        case "$trapName" in 
            EXIT | HUP | INT | QUIT | ABRT | PIPE | TERM | TSTP | USR1 | USR2)
                :
            ;;
            *)
                core_exitError $core_commandLine_exitCode_SOFTWARE "Unrecognised or unsupported trap '$trapName'"
            ;;
        esac;
    done;
    for trapName in "$@";
    do
        core_variable_array_append core_trap_handlers_${trapName} "$handler";
    done
}
core_trap_addOnCleanUp () 
{ 
    core_trap_addHandler "$1" EXIT INT TERM ABRT QUIT
}
core_trap_initialise () 
{ 
    local trapNames='EXIT|HUP|INT|QUIT|ABRT|PIPE|TERM|TSTP|USR1|USR2';
    local trapName;
    local IFS='|';
    for trapName in $trapNames;
    do
        trap "_core_trap_executeOnTrap $trapName" "$trapName";
    done
}
core_umask_setDefault () 
{ 
    umask 022
}
core_uses () 
{ 
    local libPath="$1";
    local libraryName="$2";
    shift 2;
    local namespacedModule;
    local moduleName;
    local sourced;
    local relativeFunctionsFilePath;
    local functionsFilePath;
    local delimiter="$core_variable_array_delimiter";
    local module;
    for module in "$@";
    do
        namespacedModule="$libraryName"/"$module";
        local originalIFS="$IFS";
        local IFS="$delimiter";
        if core_variable_isUnset _core_uses_alreadySourced; then
            _core_uses_alreadySourced="${namespacedModule}";
        else
            for alreadySourcedNamespacedFunction in $_core_uses_alreadySourced;
            do
                if [ "$namespacedModule" = "$alreadySourcedNamespacedFunction" ]; then
                    continue 2;
                fi;
            done;
            _core_uses_alreadySourced="${_core_uses_alreadySourced}${delimiter}${namespacedModule}";
        fi;
        local IFS="$originalIFS";
        moduleName="$(core_compatibility_basename "$namespacedModule")";
        sourced=0;
        for relativeFunctionsFilePath in "$namespacedModule" "$namespacedModule"."$core_init_shellPreferred" "$namespacedModule"/"$moduleName" "$namespacedModule"/"$moduleName"."$core_init_shellPreferred";
        do
            functionsFilePath="$libPath"/"$relativeFunctionsFilePath".functions;
            if [ -f "$functionsFilePath" ]; then
                . "$functionsFilePath" || core_exitError 72 "Can not load functions '$functionsFilePath'";
                sourced=1;
            fi;
        done;
        if [ $sourced -eq 0 ]; then
            core_exitError 72 "Can not load functions for module '$namespacedModule'";
        fi;
    done
}
core_usesIn () 
{ 
    if [ $# -eq 1 ]; then
        local parentNamespace='';
    else
        local parentNamespace="${1}/";
        shift 1;
    fi;
    local module;
    for module in "$@";
    do
        core_uses "$_program_libPath" "$core_libraryName" "${parentNamespace}${module}";
    done
}
core_validate_characterDeviceFileReadableAndWritable () 
{ 
    core_validate_pathNotEmpty "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    local messageFragment="The $category '$name' specifies a path '$value' which";
    if [ ! -e "$value" ]; then
        core_validate_exit "$messageFragment does not exist";
    fi;
    if [ ! -c "$value" ]; then
        core_validate_exit "$messageFragment is not a character device file";
    fi;
    if [ ! -r "$value" ]; then
        core_validate_exit "$messageFragment is not a readable character device file";
    fi;
    if [ ! -x "$value" ]; then
        core_validate_exit "$messageFragment is not an executable character device file";
    fi
}
core_validate_exit () 
{ 
    local message="$1";
    if [ $code -eq $core_commandLine_exitCode_USAGE ]; then
        core_commandLine_exitBadCommandLine "$message";
    else
        core_exitError $code "$message";
    fi
}
core_validate_filePathReadable () 
{ 
    core_validate_pathNotEmpty "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    local messageFragment="The $category '$name' specifies a path '$value' which";
    if [ ! -e "$value" ]; then
        core_validate_exit "$messageFragment does not exist";
    fi;
    if [ ! -f "$value" ]; then
        core_validate_exit "$messageFragment is not a file";
    fi;
    if [ ! -r "$value" ]; then
        core_validate_exit "$messageFragment is not a readable file";
    fi
}
core_validate_filePathReadableAndExecutable () 
{ 
    core_validate_filePathReadable "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    local messageFragment="The $category '$name' specifies a path '$value' which";
    if [ ! -x "$value" ]; then
        core_validate_exit "$messageFragment is not an executable file";
    fi
}
core_validate_filePathReadableAndExecutableAndNotEmpty () 
{ 
    core_validate_filePathReadableAndExecutable "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    if [ ! -s "$value" ]; then
        core_validate_exit "The $category '$name' specifies a path which is an empty file";
    fi
}
core_validate_folderPathIsReadableAndSearchableAndWritableOrCanBeCreated () 
{ 
    local value="$4";
    if [ -d "$value" ]; then
        core_validate_folderPathReadableAndSearchableAndWritable "$@";
    else
        core_validate_parentFolderPathReadableAndSearchableAndWritable "$@";
    fi
}
core_validate_folderPathReadableAndSearchable () 
{ 
    core_validate_pathNotEmpty "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    local messageFragment="The $category '$name' specifies a path '$value' which";
    if [ ! -e "$value" ]; then
        core_validate_exit "$messageFragment does not exist";
    fi;
    if [ ! -d "$value" ]; then
        core_validate_exit "$messageFragment is not a directory";
    fi;
    if [ ! -r "$value" ]; then
        core_validate_exit "$messageFragment is not a readable directory";
    fi;
    if [ ! -x "$value" ]; then
        core_validate_exit "$messageFragment is not a searchable directory";
    fi
}
core_validate_folderPathReadableAndSearchableAndWritable () 
{ 
    core_validate_folderPathReadableAndSearchable "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    if [ ! -w "$value" ]; then
        core_validate_exit "The $category '$name' specifies a path '$value' which is not a writable directory";
    fi
}
core_validate_isBoolean () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    set +e;
    core_variable_isTrue "$value";
    local exitCode=$?;
    set -e;
    if [ $exitCode -eq 2 ]; then
        core_validate_exit "The $category '$name' should be yes or no, not '$value'";
    fi
}
core_validate_isUnsignedInteger () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    case "$value" in 
        '' | *[!0-9]*)
            core_validate_exit "The $category '$name' should be an unsigned integer, not '$value'"
        ;;
        *)
            :
        ;;
    esac
}
core_validate_nonDynamicPort () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    core_validate_isUnsignedInteger $code "$category" "$name" "$value";
    if [ $value -lt 1 ]; then
        core_validate_exit "The $category '$name' should be between 1 and 65535, not '$value'";
    fi;
    if [ $value -gt 65535 ]; then
        core_validate_exit "The $category '$name' should be between 1 and 65535, not '$value'";
    fi
}
core_validate_parentFolderPathReadableAndSearchable () 
{ 
    core_validate_pathNotEmpty "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    if [ "$value" = '/' ]; then
        core_validate_exit "The $category '$name' specifies a path '$value' with no parent";
    fi;
    if [ "$(core_compatibility_basename "$value")" = "$value" ]; then
        local parentPath="$(pwd)"/..;
    else
        local parentPath="$(core_compatibility_dirname "$value")";
    fi;
    local messageFragment="The $category '$name' specifies a path '$value' with a parent which";
    if [ ! -e "$parentPath" ]; then
        core_validate_exit "$messageFragment does not exist";
    fi;
    if [ ! -d "$parentPath" ]; then
        core_validate_exit "$messageFragment is not a directory";
    fi;
    if [ ! -r "$parentPath" ]; then
        core_validate_exit "$messageFragment is not a readable directory";
    fi;
    if [ ! -x "$parentPath" ]; then
        core_validate_exit "$messageFragment is not a searchable directory";
    fi
}
core_validate_parentFolderPathReadableAndSearchableAndWritable () 
{ 
    core_validate_parentFolderPathReadableAndSearchable "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    if [ "$value" = '/' ]; then
        core_validate_exit "The $category '$name' specifies a path '$value' with no parent";
    fi;
    if [ "$(core_compatibility_basename "$value")" = "$value" ]; then
        local parentPath="$(pwd)"/..;
    else
        local parentPath="$(core_compatibility_dirname "$value")";
    fi;
    if [ ! -w "$parentPath" ]; then
        core_validate_exit "The $category '$name' specifies a path '$value' with parent which is not a writable directory";
    fi
}
core_validate_pathNotEmpty () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    if [ -z "$value" ]; then
        core_validate_exit "The $category '$name' specifies a path '$value' which is empty";
    fi
}
core_validate_socketPathReadableAndWritable () 
{ 
    core_validate_pathNotEmpty "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    local messageFragment="The $category '$name' specifies a path '$value' which";
    if [ ! -e "$value" ]; then
        core_validate_exit "$messageFragment does not exist";
    fi;
    if [ ! -S "$value" ]; then
        core_validate_exit "$messageFragment is not a socket";
    fi;
    if [ ! -r "$value" ]; then
        core_validate_exit "$messageFragment is not a readable socket";
    fi;
    if [ ! -x "$value" ]; then
        core_validate_exit "$messageFragment is not an executable socket";
    fi
}
core_variable_allButFirst () 
{ 
    core_variable_allButFirstN "$1" 1
}
core_variable_allButFirstN () 
{ 
    local value="$1";
    local numberToOmit=$2;
    local length=${#value};
    local endLength=$((length - numberToOmit));
    if [ $endLength -lt 1 ]; then
        return;
    fi;
    local count=0;
    local match='';
    local copy='';
    _core_variable_copy '?' $endLength;
    local prefix="${value%$copy}";
    printf '%s' "${value#$prefix}"
}
core_variable_allButLast () 
{ 
    core_variable_allButLastN "$1" 1
}
core_variable_allButLastN () 
{ 
    local value="$1";
    local numberToOmit=$2;
    local length=${#value};
    local endLength=$((length - numberToOmit));
    if [ $endLength -lt 1 ]; then
        return;
    fi;
    local count=0;
    local match='';
    local copy='';
    _core_variable_copy '?' $endLength;
    local suffix="${value#$copy}";
    printf '%s' "${value%$suffix}"
}
core_variable_array_append () 
{ 
    local variableName="$1";
    shift 1;
    local argument;
    for argument in "$@";
    do
        if core_variable_array_isUnset "$variableName"; then
            core_variable_array_initialise "$variableName";
            core_variable_setVariable "$variableName" "$argument";
            core_variable_setVariable "${variableName}_initialised" 1;
        else
            core_variable_indirectValue "${variableName}_initialised";
            core_variable_setVariable "${variableName}_initialised" $((core_variable_indirectValue_result+1));
            core_variable_indirectValue "$variableName";
            core_variable_setVariable "$variableName" "${core_variable_indirectValue_result}$core_variable_array_delimiter${argument}";
        fi;
    done
}
core_variable_array_appendUniquely () 
{ 
    local variableName="$1";
    shift 1;
    local argument;
    for argument in "$@";
    do
        if ! core_variable_array_contains "$variableName" "$argument"; then
            core_variable_array_append "$variableName" "$argument";
        fi;
    done
}
core_variable_array_at () 
{ 
    local variableName="$1";
    local index=$2;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    set -- $core_variable_indirectValue_result;
    IFS="$originalIFS";
    eval "core_variable_array_index_element=\"\$${index}\""
}
core_variable_array_contains () 
{ 
    local variableName="$1";
    local containsValue="$2";
    if core_variable_array_iterateShortcut "$variableName" _core_variable_array_contains_check; then
        return 0;
    fi;
    return 1
}
core_variable_array_initialise () 
{ 
    local variableName="$1";
    local variableNameInitialised="${variableName}_initialised";
    if core_variable_isSet "$variableNameInitialised"; then
        local core_variable_indirectValue_result;
        core_variable_indirectValue "$variableNameInitialised";
        if [ -n "$core_variable_indirectValue_result" ]; then
            return 0;
        fi;
    fi;
    core_variable_setVariable "$variableName" '';
    core_variable_setVariable "$variableNameInitialised" 0
}
core_variable_array_isEmpty () 
{ 
    local variableName="$1";
    _core_variable_array_isEmpty
}
core_variable_array_isSet () 
{ 
    local variableName="$1";
    local variableNameInitialised="${variableName}_initialised";
    if core_variable_isSet "$variableNameInitialised"; then
        local core_variable_indirectValue_result;
        core_variable_indirectValue "$variableNameInitialised";
        if [ ${core_variable_indirectValue_result} -gt 0 ]; then
            return 0;
        else
            return 1;
        fi;
    fi;
    return 1
}
core_variable_array_isUnset () 
{ 
    ! core_variable_array_isSet "$1"
}
core_variable_array_iterate () 
{ 
    local variableName="$1";
    local callback="$2";
    shift 2;
    if _core_variable_array_isEmpty; then
        return 0;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    local core_variable_array_element;
    for core_variable_array_element in $core_variable_indirectValue_result;
    do
        IFS="$originalIFS";
        $callback "$@";
    done;
    IFS="$originalIFS"
}
core_variable_array_iterateAsCallbacks () 
{ 
    local variableName="$1";
    shift 1;
    if _core_variable_array_isEmpty; then
        return 0;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    local callback;
    for callback in $core_variable_indirectValue_result;
    do
        IFS="$originalIFS";
        "$callback" "$@";
    done;
    IFS="$originalIFS"
}
core_variable_array_iterateAsCallbacksShortcut () 
{ 
    local variableName="$1";
    shift 1;
    if _core_variable_array_isEmpty; then
        return 1;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    local callback;
    for callback in $core_variable_indirectValue_result;
    do
        IFS="$originalIFS";
        if "$callback" "$@"; then
            return 0;
        fi;
    done;
    IFS="$originalIFS";
    return 1
}
core_variable_array_iterateShortcut () 
{ 
    local variableName="$1";
    local callback="$2";
    shift 2;
    if _core_variable_array_isEmpty; then
        return 1;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    local core_variable_array_element;
    for core_variable_array_element in $core_variable_indirectValue_result;
    do
        IFS="$originalIFS";
        if $callback "$@"; then
            return 0;
        fi;
    done;
    IFS="$originalIFS";
    return 1
}
core_variable_array_length () 
{ 
    local variableName="$1";
    shift 1;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "${variableName}_initialised";
    printf '%s' $core_variable_indirectValue_result
}
core_variable_array_passToFunctionAsArguments () 
{ 
    local variableName="$1";
    local function="$2";
    shift 2;
    if [ $# -ne 0 ]; then
        core_exitError $core_commandLine_exitCode_SOFTWARE "Only varargs from array are allowed";
    fi;
    if _core_variable_array_isEmpty; then
        "$function";
        return 0;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    set -- $core_variable_indirectValue_result;
    IFS="$originalIFS";
    "$function" "$@"
}
core_variable_array_string () 
{ 
    local variableName="$1";
    local separator="$2";
    if _core_variable_array_isEmpty; then
        return 0;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local count=0;
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    for core_variable_array_element in $core_variable_indirectValue_result;
    do
        IFS="$originalIFS";
        if [ $count -eq 0 ]; then
            printf '%s' "$core_variable_array_element";
        else
            printf '%s%s' "$separator" "$core_variable_array_element";
        fi;
        count=$((count+1));
    done;
    IFS="$originalIFS"
}
core_variable_array_unset () 
{ 
    local variableName="$1";
    local variableNameInitialised="${variableName}_initialised";
    core_variable_unset "$variableName";
    core_variable_unset "$variableNameInitialised"
}
core_variable_array_warning () 
{ 
    if [ "$core_init_preferred_shell" = 'sh' ]; then
        if core_variable_isSet BASH_VERSINFO; then
            if [ "$BASH_VERSINFO" -eq 3 ]; then
                core_message NOTICE "There's a horrible bug in bash 3, which when run as sh, that treats 'local variableName' as being set to empty, not as unset. We have to support bash 3 for Mac OS X and MinGW.";
                core_message NOTICE "There's a horrible bug in bash 3, which when run as sh, that doesn't like IFS='\001'.";
            fi;
        fi;
    fi
}
core_variable_characterByCharacter () 
{ 
    local value="$1";
    local callback="$2";
    local TMP_FILE;
    core_temporaryFiles_newFileToRemoveOnExit;
    local inputFile="$TMP_FILE";
    prinf '%s' "$value" > "$inputFile";
    core_file_characterByCharacter "$inputFile" _core_variable_characterByCharacter;
    rm -f "$inputFile"
}
core_variable_contains () 
{ 
    local value="$1";
    local contains="$2";
    case "$value" in 
        *"$contains"*)
            return 0
        ;;
    esac;
    return 1
}
core_variable_doesNotEndWith () 
{ 
    ! core_variable_endsWith "$@"
}
core_variable_doesNotStartWith () 
{ 
    ! core_variable_startsWith "$@"
}
core_variable_endsWith () 
{ 
    local value="$1";
    local contains="$2";
    case "$value" in 
        *"$contains")
            return 0
        ;;
    esac;
    return 1
}
core_variable_escapeForSingleQuotedLiteralInHeredoc () 
{ 
    local value="$1";
    local singleQuote="'";
    local doubleQuote='"';
    local replacement="${singleQuote}${doubleQuote}${singleQuote}${doubleQuote}${singleQuote}";
    printf '%s' "$value" | sed "s/${singleQuote}/${replacement}/g"
}
core_variable_firstCharacter () 
{ 
    local value="$1";
    local suffix="${value#?}";
    printf '%s' "${value%$suffix}"
}
core_variable_indirectValue () 
{ 
    eval "core_variable_indirectValue_result=\"\$${1}\""
}
core_variable_isFalse () 
{ 
    _core_variable_parseBoolean "$1" 1 0 2
}
core_variable_isInvalidBoolean () 
{ 
    _core_variable_parseBoolean "$1" 1 1 0
}
core_variable_isSet () 
{ 
    local x;
    eval x="\"\${$1+set}\"";
    [ "$x" = 'set' ]
}
core_variable_isTrue () 
{ 
    _core_variable_parseBoolean "$1" 0 1 2
}
core_variable_isUnset () 
{ 
    ! core_variable_isSet "$1"
}
core_variable_isUnsetOrEmpty () 
{ 
    local variableName="$1";
    if core_variable_isUnset "$variableName"; then
        return 0;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    if [ -z "$core_variable_indirectValue_result" ]; then
        return 0;
    fi;
    return 1
}
core_variable_lastCharacter () 
{ 
    local value="$1";
    local prefix="${value%?}";
    printf '%s' "${value#$prefix}"
}
core_variable_matches () 
{ 
    local value="$1";
    local match="$2";
    case "$value" in 
        $match)
            return 0
        ;;
    esac;
    return 1
}
core_variable_setVariable () 
{ 
    eval "$1"'=$2'
}
core_variable_setVariableIfUnset () 
{ 
    local variableName="$1";
    local variableDefaultValue="$2";
    if core_variable_isUnset "$variableName"; then
        eval "$variableName='$variableDefaultValue'";
    fi
}
core_variable_startsWith () 
{ 
    local value="$1";
    local contains="$2";
    case "$value" in 
        "$contains"*)
            return 0
        ;;
    esac;
    return 1
}
core_variable_trimSpaceAndHorizontalTab () 
{ 
    local value="$1";
    value="${value#"${value%%[![:blank:]]*}"}";
    printf '%s' "${value%"${value##*[![:blank:]]}"}"
}
core_variable_trimWhitespace () 
{ 
    local value="$1";
    value="${value#"${value%%[![:space:]]*}"}";
    printf '%s' "${value%"${value##*[![:space:]]}"}"
}
core_variable_unset () 
{ 
    unset "$@"
}
core_init_main "$@"
